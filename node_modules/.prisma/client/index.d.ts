
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model GoogleAccount
 * 
 */
export type GoogleAccount = $Result.DefaultSelection<Prisma.$GoogleAccountPayload>
/**
 * Model EmailItem
 * 
 */
export type EmailItem = $Result.DefaultSelection<Prisma.$EmailItemPayload>
/**
 * Model CalendarEvent
 * 
 */
export type CalendarEvent = $Result.DefaultSelection<Prisma.$CalendarEventPayload>
/**
 * Model DocItem
 * 
 */
export type DocItem = $Result.DefaultSelection<Prisma.$DocItemPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model TriageRun
 * 
 */
export type TriageRun = $Result.DefaultSelection<Prisma.$TriageRunPayload>
/**
 * Model LearningMaterial
 * 
 */
export type LearningMaterial = $Result.DefaultSelection<Prisma.$LearningMaterialPayload>
/**
 * Model LearningArtifact
 * 
 */
export type LearningArtifact = $Result.DefaultSelection<Prisma.$LearningArtifactPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.googleAccount`: Exposes CRUD operations for the **GoogleAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoogleAccounts
    * const googleAccounts = await prisma.googleAccount.findMany()
    * ```
    */
  get googleAccount(): Prisma.GoogleAccountDelegate<ExtArgs>;

  /**
   * `prisma.emailItem`: Exposes CRUD operations for the **EmailItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailItems
    * const emailItems = await prisma.emailItem.findMany()
    * ```
    */
  get emailItem(): Prisma.EmailItemDelegate<ExtArgs>;

  /**
   * `prisma.calendarEvent`: Exposes CRUD operations for the **CalendarEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEvents
    * const calendarEvents = await prisma.calendarEvent.findMany()
    * ```
    */
  get calendarEvent(): Prisma.CalendarEventDelegate<ExtArgs>;

  /**
   * `prisma.docItem`: Exposes CRUD operations for the **DocItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocItems
    * const docItems = await prisma.docItem.findMany()
    * ```
    */
  get docItem(): Prisma.DocItemDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs>;

  /**
   * `prisma.triageRun`: Exposes CRUD operations for the **TriageRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TriageRuns
    * const triageRuns = await prisma.triageRun.findMany()
    * ```
    */
  get triageRun(): Prisma.TriageRunDelegate<ExtArgs>;

  /**
   * `prisma.learningMaterial`: Exposes CRUD operations for the **LearningMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningMaterials
    * const learningMaterials = await prisma.learningMaterial.findMany()
    * ```
    */
  get learningMaterial(): Prisma.LearningMaterialDelegate<ExtArgs>;

  /**
   * `prisma.learningArtifact`: Exposes CRUD operations for the **LearningArtifact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningArtifacts
    * const learningArtifacts = await prisma.learningArtifact.findMany()
    * ```
    */
  get learningArtifact(): Prisma.LearningArtifactDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    GoogleAccount: 'GoogleAccount',
    EmailItem: 'EmailItem',
    CalendarEvent: 'CalendarEvent',
    DocItem: 'DocItem',
    Task: 'Task',
    Plan: 'Plan',
    TriageRun: 'TriageRun',
    LearningMaterial: 'LearningMaterial',
    LearningArtifact: 'LearningArtifact'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "googleAccount" | "emailItem" | "calendarEvent" | "docItem" | "task" | "plan" | "triageRun" | "learningMaterial" | "learningArtifact"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      GoogleAccount: {
        payload: Prisma.$GoogleAccountPayload<ExtArgs>
        fields: Prisma.GoogleAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoogleAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoogleAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAccountPayload>
          }
          findFirst: {
            args: Prisma.GoogleAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoogleAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAccountPayload>
          }
          findMany: {
            args: Prisma.GoogleAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAccountPayload>[]
          }
          create: {
            args: Prisma.GoogleAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAccountPayload>
          }
          createMany: {
            args: Prisma.GoogleAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoogleAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAccountPayload>[]
          }
          delete: {
            args: Prisma.GoogleAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAccountPayload>
          }
          update: {
            args: Prisma.GoogleAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAccountPayload>
          }
          deleteMany: {
            args: Prisma.GoogleAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoogleAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoogleAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAccountPayload>
          }
          aggregate: {
            args: Prisma.GoogleAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoogleAccount>
          }
          groupBy: {
            args: Prisma.GoogleAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoogleAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoogleAccountCountArgs<ExtArgs>
            result: $Utils.Optional<GoogleAccountCountAggregateOutputType> | number
          }
        }
      }
      EmailItem: {
        payload: Prisma.$EmailItemPayload<ExtArgs>
        fields: Prisma.EmailItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailItemPayload>
          }
          findFirst: {
            args: Prisma.EmailItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailItemPayload>
          }
          findMany: {
            args: Prisma.EmailItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailItemPayload>[]
          }
          create: {
            args: Prisma.EmailItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailItemPayload>
          }
          createMany: {
            args: Prisma.EmailItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailItemPayload>[]
          }
          delete: {
            args: Prisma.EmailItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailItemPayload>
          }
          update: {
            args: Prisma.EmailItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailItemPayload>
          }
          deleteMany: {
            args: Prisma.EmailItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailItemPayload>
          }
          aggregate: {
            args: Prisma.EmailItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailItem>
          }
          groupBy: {
            args: Prisma.EmailItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailItemCountArgs<ExtArgs>
            result: $Utils.Optional<EmailItemCountAggregateOutputType> | number
          }
        }
      }
      CalendarEvent: {
        payload: Prisma.$CalendarEventPayload<ExtArgs>
        fields: Prisma.CalendarEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findFirst: {
            args: Prisma.CalendarEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findMany: {
            args: Prisma.CalendarEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          create: {
            args: Prisma.CalendarEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          createMany: {
            args: Prisma.CalendarEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          delete: {
            args: Prisma.CalendarEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          update: {
            args: Prisma.CalendarEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          aggregate: {
            args: Prisma.CalendarEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEvent>
          }
          groupBy: {
            args: Prisma.CalendarEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEventCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventCountAggregateOutputType> | number
          }
        }
      }
      DocItem: {
        payload: Prisma.$DocItemPayload<ExtArgs>
        fields: Prisma.DocItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocItemPayload>
          }
          findFirst: {
            args: Prisma.DocItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocItemPayload>
          }
          findMany: {
            args: Prisma.DocItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocItemPayload>[]
          }
          create: {
            args: Prisma.DocItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocItemPayload>
          }
          createMany: {
            args: Prisma.DocItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocItemPayload>[]
          }
          delete: {
            args: Prisma.DocItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocItemPayload>
          }
          update: {
            args: Prisma.DocItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocItemPayload>
          }
          deleteMany: {
            args: Prisma.DocItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocItemPayload>
          }
          aggregate: {
            args: Prisma.DocItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocItem>
          }
          groupBy: {
            args: Prisma.DocItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocItemCountArgs<ExtArgs>
            result: $Utils.Optional<DocItemCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      TriageRun: {
        payload: Prisma.$TriageRunPayload<ExtArgs>
        fields: Prisma.TriageRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TriageRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriageRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TriageRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriageRunPayload>
          }
          findFirst: {
            args: Prisma.TriageRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriageRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TriageRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriageRunPayload>
          }
          findMany: {
            args: Prisma.TriageRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriageRunPayload>[]
          }
          create: {
            args: Prisma.TriageRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriageRunPayload>
          }
          createMany: {
            args: Prisma.TriageRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TriageRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriageRunPayload>[]
          }
          delete: {
            args: Prisma.TriageRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriageRunPayload>
          }
          update: {
            args: Prisma.TriageRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriageRunPayload>
          }
          deleteMany: {
            args: Prisma.TriageRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TriageRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TriageRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriageRunPayload>
          }
          aggregate: {
            args: Prisma.TriageRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTriageRun>
          }
          groupBy: {
            args: Prisma.TriageRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<TriageRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.TriageRunCountArgs<ExtArgs>
            result: $Utils.Optional<TriageRunCountAggregateOutputType> | number
          }
        }
      }
      LearningMaterial: {
        payload: Prisma.$LearningMaterialPayload<ExtArgs>
        fields: Prisma.LearningMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningMaterialPayload>
          }
          findFirst: {
            args: Prisma.LearningMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningMaterialPayload>
          }
          findMany: {
            args: Prisma.LearningMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningMaterialPayload>[]
          }
          create: {
            args: Prisma.LearningMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningMaterialPayload>
          }
          createMany: {
            args: Prisma.LearningMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningMaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningMaterialPayload>[]
          }
          delete: {
            args: Prisma.LearningMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningMaterialPayload>
          }
          update: {
            args: Prisma.LearningMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningMaterialPayload>
          }
          deleteMany: {
            args: Prisma.LearningMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearningMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningMaterialPayload>
          }
          aggregate: {
            args: Prisma.LearningMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningMaterial>
          }
          groupBy: {
            args: Prisma.LearningMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<LearningMaterialCountAggregateOutputType> | number
          }
        }
      }
      LearningArtifact: {
        payload: Prisma.$LearningArtifactPayload<ExtArgs>
        fields: Prisma.LearningArtifactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningArtifactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningArtifactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningArtifactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningArtifactPayload>
          }
          findFirst: {
            args: Prisma.LearningArtifactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningArtifactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningArtifactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningArtifactPayload>
          }
          findMany: {
            args: Prisma.LearningArtifactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningArtifactPayload>[]
          }
          create: {
            args: Prisma.LearningArtifactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningArtifactPayload>
          }
          createMany: {
            args: Prisma.LearningArtifactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningArtifactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningArtifactPayload>[]
          }
          delete: {
            args: Prisma.LearningArtifactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningArtifactPayload>
          }
          update: {
            args: Prisma.LearningArtifactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningArtifactPayload>
          }
          deleteMany: {
            args: Prisma.LearningArtifactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningArtifactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearningArtifactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningArtifactPayload>
          }
          aggregate: {
            args: Prisma.LearningArtifactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningArtifact>
          }
          groupBy: {
            args: Prisma.LearningArtifactGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningArtifactGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningArtifactCountArgs<ExtArgs>
            result: $Utils.Optional<LearningArtifactCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    emailItems: number
    calendarEvents: number
    docItems: number
    tasks: number
    plans: number
    triageRuns: number
    learningMaterials: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailItems?: boolean | UserCountOutputTypeCountEmailItemsArgs
    calendarEvents?: boolean | UserCountOutputTypeCountCalendarEventsArgs
    docItems?: boolean | UserCountOutputTypeCountDocItemsArgs
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    plans?: boolean | UserCountOutputTypeCountPlansArgs
    triageRuns?: boolean | UserCountOutputTypeCountTriageRunsArgs
    learningMaterials?: boolean | UserCountOutputTypeCountLearningMaterialsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCalendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTriageRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriageRunWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLearningMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningMaterialWhereInput
  }


  /**
   * Count Type LearningMaterialCountOutputType
   */

  export type LearningMaterialCountOutputType = {
    artifacts: number
  }

  export type LearningMaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifacts?: boolean | LearningMaterialCountOutputTypeCountArtifactsArgs
  }

  // Custom InputTypes
  /**
   * LearningMaterialCountOutputType without action
   */
  export type LearningMaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterialCountOutputType
     */
    select?: LearningMaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LearningMaterialCountOutputType without action
   */
  export type LearningMaterialCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningArtifactWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    googleAccount?: boolean | User$googleAccountArgs<ExtArgs>
    emailItems?: boolean | User$emailItemsArgs<ExtArgs>
    calendarEvents?: boolean | User$calendarEventsArgs<ExtArgs>
    docItems?: boolean | User$docItemsArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    plans?: boolean | User$plansArgs<ExtArgs>
    triageRuns?: boolean | User$triageRunsArgs<ExtArgs>
    learningMaterials?: boolean | User$learningMaterialsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    googleAccount?: boolean | User$googleAccountArgs<ExtArgs>
    emailItems?: boolean | User$emailItemsArgs<ExtArgs>
    calendarEvents?: boolean | User$calendarEventsArgs<ExtArgs>
    docItems?: boolean | User$docItemsArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    plans?: boolean | User$plansArgs<ExtArgs>
    triageRuns?: boolean | User$triageRunsArgs<ExtArgs>
    learningMaterials?: boolean | User$learningMaterialsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      googleAccount: Prisma.$GoogleAccountPayload<ExtArgs> | null
      emailItems: Prisma.$EmailItemPayload<ExtArgs>[]
      calendarEvents: Prisma.$CalendarEventPayload<ExtArgs>[]
      docItems: Prisma.$DocItemPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      plans: Prisma.$PlanPayload<ExtArgs>[]
      triageRuns: Prisma.$TriageRunPayload<ExtArgs>[]
      learningMaterials: Prisma.$LearningMaterialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    googleAccount<T extends User$googleAccountArgs<ExtArgs> = {}>(args?: Subset<T, User$googleAccountArgs<ExtArgs>>): Prisma__GoogleAccountClient<$Result.GetResult<Prisma.$GoogleAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    emailItems<T extends User$emailItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$emailItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailItemPayload<ExtArgs>, T, "findMany"> | Null>
    calendarEvents<T extends User$calendarEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$calendarEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany"> | Null>
    docItems<T extends User$docItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$docItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocItemPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends User$tasksArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    plans<T extends User$plansArgs<ExtArgs> = {}>(args?: Subset<T, User$plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany"> | Null>
    triageRuns<T extends User$triageRunsArgs<ExtArgs> = {}>(args?: Subset<T, User$triageRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriageRunPayload<ExtArgs>, T, "findMany"> | Null>
    learningMaterials<T extends User$learningMaterialsArgs<ExtArgs> = {}>(args?: Subset<T, User$learningMaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningMaterialPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.googleAccount
   */
  export type User$googleAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAccount
     */
    select?: GoogleAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAccountInclude<ExtArgs> | null
    where?: GoogleAccountWhereInput
  }

  /**
   * User.emailItems
   */
  export type User$emailItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailItem
     */
    select?: EmailItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailItemInclude<ExtArgs> | null
    where?: EmailItemWhereInput
    orderBy?: EmailItemOrderByWithRelationInput | EmailItemOrderByWithRelationInput[]
    cursor?: EmailItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailItemScalarFieldEnum | EmailItemScalarFieldEnum[]
  }

  /**
   * User.calendarEvents
   */
  export type User$calendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * User.docItems
   */
  export type User$docItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocItem
     */
    select?: DocItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocItemInclude<ExtArgs> | null
    where?: DocItemWhereInput
    orderBy?: DocItemOrderByWithRelationInput | DocItemOrderByWithRelationInput[]
    cursor?: DocItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocItemScalarFieldEnum | DocItemScalarFieldEnum[]
  }

  /**
   * User.tasks
   */
  export type User$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.plans
   */
  export type User$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    cursor?: PlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * User.triageRuns
   */
  export type User$triageRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriageRun
     */
    select?: TriageRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriageRunInclude<ExtArgs> | null
    where?: TriageRunWhereInput
    orderBy?: TriageRunOrderByWithRelationInput | TriageRunOrderByWithRelationInput[]
    cursor?: TriageRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TriageRunScalarFieldEnum | TriageRunScalarFieldEnum[]
  }

  /**
   * User.learningMaterials
   */
  export type User$learningMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterial
     */
    select?: LearningMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningMaterialInclude<ExtArgs> | null
    where?: LearningMaterialWhereInput
    orderBy?: LearningMaterialOrderByWithRelationInput | LearningMaterialOrderByWithRelationInput[]
    cursor?: LearningMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningMaterialScalarFieldEnum | LearningMaterialScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model GoogleAccount
   */

  export type AggregateGoogleAccount = {
    _count: GoogleAccountCountAggregateOutputType | null
    _avg: GoogleAccountAvgAggregateOutputType | null
    _sum: GoogleAccountSumAggregateOutputType | null
    _min: GoogleAccountMinAggregateOutputType | null
    _max: GoogleAccountMaxAggregateOutputType | null
  }

  export type GoogleAccountAvgAggregateOutputType = {
    expiryDate: number | null
  }

  export type GoogleAccountSumAggregateOutputType = {
    expiryDate: bigint | null
  }

  export type GoogleAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    googleSub: string | null
    accessTokenEnc: string | null
    refreshTokenEnc: string | null
    expiryDate: bigint | null
    scopes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoogleAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    googleSub: string | null
    accessTokenEnc: string | null
    refreshTokenEnc: string | null
    expiryDate: bigint | null
    scopes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoogleAccountCountAggregateOutputType = {
    id: number
    userId: number
    googleSub: number
    accessTokenEnc: number
    refreshTokenEnc: number
    expiryDate: number
    scopes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GoogleAccountAvgAggregateInputType = {
    expiryDate?: true
  }

  export type GoogleAccountSumAggregateInputType = {
    expiryDate?: true
  }

  export type GoogleAccountMinAggregateInputType = {
    id?: true
    userId?: true
    googleSub?: true
    accessTokenEnc?: true
    refreshTokenEnc?: true
    expiryDate?: true
    scopes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoogleAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    googleSub?: true
    accessTokenEnc?: true
    refreshTokenEnc?: true
    expiryDate?: true
    scopes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoogleAccountCountAggregateInputType = {
    id?: true
    userId?: true
    googleSub?: true
    accessTokenEnc?: true
    refreshTokenEnc?: true
    expiryDate?: true
    scopes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GoogleAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoogleAccount to aggregate.
     */
    where?: GoogleAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAccounts to fetch.
     */
    orderBy?: GoogleAccountOrderByWithRelationInput | GoogleAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoogleAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoogleAccounts
    **/
    _count?: true | GoogleAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoogleAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoogleAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoogleAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoogleAccountMaxAggregateInputType
  }

  export type GetGoogleAccountAggregateType<T extends GoogleAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateGoogleAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoogleAccount[P]>
      : GetScalarType<T[P], AggregateGoogleAccount[P]>
  }




  export type GoogleAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoogleAccountWhereInput
    orderBy?: GoogleAccountOrderByWithAggregationInput | GoogleAccountOrderByWithAggregationInput[]
    by: GoogleAccountScalarFieldEnum[] | GoogleAccountScalarFieldEnum
    having?: GoogleAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoogleAccountCountAggregateInputType | true
    _avg?: GoogleAccountAvgAggregateInputType
    _sum?: GoogleAccountSumAggregateInputType
    _min?: GoogleAccountMinAggregateInputType
    _max?: GoogleAccountMaxAggregateInputType
  }

  export type GoogleAccountGroupByOutputType = {
    id: string
    userId: string
    googleSub: string
    accessTokenEnc: string
    refreshTokenEnc: string
    expiryDate: bigint | null
    scopes: string
    createdAt: Date
    updatedAt: Date
    _count: GoogleAccountCountAggregateOutputType | null
    _avg: GoogleAccountAvgAggregateOutputType | null
    _sum: GoogleAccountSumAggregateOutputType | null
    _min: GoogleAccountMinAggregateOutputType | null
    _max: GoogleAccountMaxAggregateOutputType | null
  }

  type GetGoogleAccountGroupByPayload<T extends GoogleAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoogleAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoogleAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoogleAccountGroupByOutputType[P]>
            : GetScalarType<T[P], GoogleAccountGroupByOutputType[P]>
        }
      >
    >


  export type GoogleAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    googleSub?: boolean
    accessTokenEnc?: boolean
    refreshTokenEnc?: boolean
    expiryDate?: boolean
    scopes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["googleAccount"]>

  export type GoogleAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    googleSub?: boolean
    accessTokenEnc?: boolean
    refreshTokenEnc?: boolean
    expiryDate?: boolean
    scopes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["googleAccount"]>

  export type GoogleAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    googleSub?: boolean
    accessTokenEnc?: boolean
    refreshTokenEnc?: boolean
    expiryDate?: boolean
    scopes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GoogleAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GoogleAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GoogleAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoogleAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      googleSub: string
      accessTokenEnc: string
      refreshTokenEnc: string
      expiryDate: bigint | null
      scopes: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["googleAccount"]>
    composites: {}
  }

  type GoogleAccountGetPayload<S extends boolean | null | undefined | GoogleAccountDefaultArgs> = $Result.GetResult<Prisma.$GoogleAccountPayload, S>

  type GoogleAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GoogleAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GoogleAccountCountAggregateInputType | true
    }

  export interface GoogleAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoogleAccount'], meta: { name: 'GoogleAccount' } }
    /**
     * Find zero or one GoogleAccount that matches the filter.
     * @param {GoogleAccountFindUniqueArgs} args - Arguments to find a GoogleAccount
     * @example
     * // Get one GoogleAccount
     * const googleAccount = await prisma.googleAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoogleAccountFindUniqueArgs>(args: SelectSubset<T, GoogleAccountFindUniqueArgs<ExtArgs>>): Prisma__GoogleAccountClient<$Result.GetResult<Prisma.$GoogleAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GoogleAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GoogleAccountFindUniqueOrThrowArgs} args - Arguments to find a GoogleAccount
     * @example
     * // Get one GoogleAccount
     * const googleAccount = await prisma.googleAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoogleAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, GoogleAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoogleAccountClient<$Result.GetResult<Prisma.$GoogleAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GoogleAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAccountFindFirstArgs} args - Arguments to find a GoogleAccount
     * @example
     * // Get one GoogleAccount
     * const googleAccount = await prisma.googleAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoogleAccountFindFirstArgs>(args?: SelectSubset<T, GoogleAccountFindFirstArgs<ExtArgs>>): Prisma__GoogleAccountClient<$Result.GetResult<Prisma.$GoogleAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GoogleAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAccountFindFirstOrThrowArgs} args - Arguments to find a GoogleAccount
     * @example
     * // Get one GoogleAccount
     * const googleAccount = await prisma.googleAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoogleAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, GoogleAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoogleAccountClient<$Result.GetResult<Prisma.$GoogleAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GoogleAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoogleAccounts
     * const googleAccounts = await prisma.googleAccount.findMany()
     * 
     * // Get first 10 GoogleAccounts
     * const googleAccounts = await prisma.googleAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const googleAccountWithIdOnly = await prisma.googleAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoogleAccountFindManyArgs>(args?: SelectSubset<T, GoogleAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoogleAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GoogleAccount.
     * @param {GoogleAccountCreateArgs} args - Arguments to create a GoogleAccount.
     * @example
     * // Create one GoogleAccount
     * const GoogleAccount = await prisma.googleAccount.create({
     *   data: {
     *     // ... data to create a GoogleAccount
     *   }
     * })
     * 
     */
    create<T extends GoogleAccountCreateArgs>(args: SelectSubset<T, GoogleAccountCreateArgs<ExtArgs>>): Prisma__GoogleAccountClient<$Result.GetResult<Prisma.$GoogleAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GoogleAccounts.
     * @param {GoogleAccountCreateManyArgs} args - Arguments to create many GoogleAccounts.
     * @example
     * // Create many GoogleAccounts
     * const googleAccount = await prisma.googleAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoogleAccountCreateManyArgs>(args?: SelectSubset<T, GoogleAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoogleAccounts and returns the data saved in the database.
     * @param {GoogleAccountCreateManyAndReturnArgs} args - Arguments to create many GoogleAccounts.
     * @example
     * // Create many GoogleAccounts
     * const googleAccount = await prisma.googleAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoogleAccounts and only return the `id`
     * const googleAccountWithIdOnly = await prisma.googleAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoogleAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, GoogleAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoogleAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GoogleAccount.
     * @param {GoogleAccountDeleteArgs} args - Arguments to delete one GoogleAccount.
     * @example
     * // Delete one GoogleAccount
     * const GoogleAccount = await prisma.googleAccount.delete({
     *   where: {
     *     // ... filter to delete one GoogleAccount
     *   }
     * })
     * 
     */
    delete<T extends GoogleAccountDeleteArgs>(args: SelectSubset<T, GoogleAccountDeleteArgs<ExtArgs>>): Prisma__GoogleAccountClient<$Result.GetResult<Prisma.$GoogleAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GoogleAccount.
     * @param {GoogleAccountUpdateArgs} args - Arguments to update one GoogleAccount.
     * @example
     * // Update one GoogleAccount
     * const googleAccount = await prisma.googleAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoogleAccountUpdateArgs>(args: SelectSubset<T, GoogleAccountUpdateArgs<ExtArgs>>): Prisma__GoogleAccountClient<$Result.GetResult<Prisma.$GoogleAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GoogleAccounts.
     * @param {GoogleAccountDeleteManyArgs} args - Arguments to filter GoogleAccounts to delete.
     * @example
     * // Delete a few GoogleAccounts
     * const { count } = await prisma.googleAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoogleAccountDeleteManyArgs>(args?: SelectSubset<T, GoogleAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoogleAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoogleAccounts
     * const googleAccount = await prisma.googleAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoogleAccountUpdateManyArgs>(args: SelectSubset<T, GoogleAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GoogleAccount.
     * @param {GoogleAccountUpsertArgs} args - Arguments to update or create a GoogleAccount.
     * @example
     * // Update or create a GoogleAccount
     * const googleAccount = await prisma.googleAccount.upsert({
     *   create: {
     *     // ... data to create a GoogleAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoogleAccount we want to update
     *   }
     * })
     */
    upsert<T extends GoogleAccountUpsertArgs>(args: SelectSubset<T, GoogleAccountUpsertArgs<ExtArgs>>): Prisma__GoogleAccountClient<$Result.GetResult<Prisma.$GoogleAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GoogleAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAccountCountArgs} args - Arguments to filter GoogleAccounts to count.
     * @example
     * // Count the number of GoogleAccounts
     * const count = await prisma.googleAccount.count({
     *   where: {
     *     // ... the filter for the GoogleAccounts we want to count
     *   }
     * })
    **/
    count<T extends GoogleAccountCountArgs>(
      args?: Subset<T, GoogleAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoogleAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoogleAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoogleAccountAggregateArgs>(args: Subset<T, GoogleAccountAggregateArgs>): Prisma.PrismaPromise<GetGoogleAccountAggregateType<T>>

    /**
     * Group by GoogleAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoogleAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoogleAccountGroupByArgs['orderBy'] }
        : { orderBy?: GoogleAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoogleAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoogleAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoogleAccount model
   */
  readonly fields: GoogleAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoogleAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoogleAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoogleAccount model
   */ 
  interface GoogleAccountFieldRefs {
    readonly id: FieldRef<"GoogleAccount", 'String'>
    readonly userId: FieldRef<"GoogleAccount", 'String'>
    readonly googleSub: FieldRef<"GoogleAccount", 'String'>
    readonly accessTokenEnc: FieldRef<"GoogleAccount", 'String'>
    readonly refreshTokenEnc: FieldRef<"GoogleAccount", 'String'>
    readonly expiryDate: FieldRef<"GoogleAccount", 'BigInt'>
    readonly scopes: FieldRef<"GoogleAccount", 'String'>
    readonly createdAt: FieldRef<"GoogleAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"GoogleAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GoogleAccount findUnique
   */
  export type GoogleAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAccount
     */
    select?: GoogleAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAccountInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAccount to fetch.
     */
    where: GoogleAccountWhereUniqueInput
  }

  /**
   * GoogleAccount findUniqueOrThrow
   */
  export type GoogleAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAccount
     */
    select?: GoogleAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAccountInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAccount to fetch.
     */
    where: GoogleAccountWhereUniqueInput
  }

  /**
   * GoogleAccount findFirst
   */
  export type GoogleAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAccount
     */
    select?: GoogleAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAccountInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAccount to fetch.
     */
    where?: GoogleAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAccounts to fetch.
     */
    orderBy?: GoogleAccountOrderByWithRelationInput | GoogleAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoogleAccounts.
     */
    cursor?: GoogleAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoogleAccounts.
     */
    distinct?: GoogleAccountScalarFieldEnum | GoogleAccountScalarFieldEnum[]
  }

  /**
   * GoogleAccount findFirstOrThrow
   */
  export type GoogleAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAccount
     */
    select?: GoogleAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAccountInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAccount to fetch.
     */
    where?: GoogleAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAccounts to fetch.
     */
    orderBy?: GoogleAccountOrderByWithRelationInput | GoogleAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoogleAccounts.
     */
    cursor?: GoogleAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoogleAccounts.
     */
    distinct?: GoogleAccountScalarFieldEnum | GoogleAccountScalarFieldEnum[]
  }

  /**
   * GoogleAccount findMany
   */
  export type GoogleAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAccount
     */
    select?: GoogleAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAccountInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAccounts to fetch.
     */
    where?: GoogleAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAccounts to fetch.
     */
    orderBy?: GoogleAccountOrderByWithRelationInput | GoogleAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoogleAccounts.
     */
    cursor?: GoogleAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAccounts.
     */
    skip?: number
    distinct?: GoogleAccountScalarFieldEnum | GoogleAccountScalarFieldEnum[]
  }

  /**
   * GoogleAccount create
   */
  export type GoogleAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAccount
     */
    select?: GoogleAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a GoogleAccount.
     */
    data: XOR<GoogleAccountCreateInput, GoogleAccountUncheckedCreateInput>
  }

  /**
   * GoogleAccount createMany
   */
  export type GoogleAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoogleAccounts.
     */
    data: GoogleAccountCreateManyInput | GoogleAccountCreateManyInput[]
  }

  /**
   * GoogleAccount createManyAndReturn
   */
  export type GoogleAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAccount
     */
    select?: GoogleAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GoogleAccounts.
     */
    data: GoogleAccountCreateManyInput | GoogleAccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoogleAccount update
   */
  export type GoogleAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAccount
     */
    select?: GoogleAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a GoogleAccount.
     */
    data: XOR<GoogleAccountUpdateInput, GoogleAccountUncheckedUpdateInput>
    /**
     * Choose, which GoogleAccount to update.
     */
    where: GoogleAccountWhereUniqueInput
  }

  /**
   * GoogleAccount updateMany
   */
  export type GoogleAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoogleAccounts.
     */
    data: XOR<GoogleAccountUpdateManyMutationInput, GoogleAccountUncheckedUpdateManyInput>
    /**
     * Filter which GoogleAccounts to update
     */
    where?: GoogleAccountWhereInput
  }

  /**
   * GoogleAccount upsert
   */
  export type GoogleAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAccount
     */
    select?: GoogleAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the GoogleAccount to update in case it exists.
     */
    where: GoogleAccountWhereUniqueInput
    /**
     * In case the GoogleAccount found by the `where` argument doesn't exist, create a new GoogleAccount with this data.
     */
    create: XOR<GoogleAccountCreateInput, GoogleAccountUncheckedCreateInput>
    /**
     * In case the GoogleAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoogleAccountUpdateInput, GoogleAccountUncheckedUpdateInput>
  }

  /**
   * GoogleAccount delete
   */
  export type GoogleAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAccount
     */
    select?: GoogleAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAccountInclude<ExtArgs> | null
    /**
     * Filter which GoogleAccount to delete.
     */
    where: GoogleAccountWhereUniqueInput
  }

  /**
   * GoogleAccount deleteMany
   */
  export type GoogleAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoogleAccounts to delete
     */
    where?: GoogleAccountWhereInput
  }

  /**
   * GoogleAccount without action
   */
  export type GoogleAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAccount
     */
    select?: GoogleAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAccountInclude<ExtArgs> | null
  }


  /**
   * Model EmailItem
   */

  export type AggregateEmailItem = {
    _count: EmailItemCountAggregateOutputType | null
    _min: EmailItemMinAggregateOutputType | null
    _max: EmailItemMaxAggregateOutputType | null
  }

  export type EmailItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    gmailId: string | null
    threadId: string | null
    from: string | null
    subject: string | null
    snippet: string | null
    receivedAt: Date | null
    isUnread: boolean | null
    rawJson: string | null
  }

  export type EmailItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    gmailId: string | null
    threadId: string | null
    from: string | null
    subject: string | null
    snippet: string | null
    receivedAt: Date | null
    isUnread: boolean | null
    rawJson: string | null
  }

  export type EmailItemCountAggregateOutputType = {
    id: number
    userId: number
    gmailId: number
    threadId: number
    from: number
    subject: number
    snippet: number
    receivedAt: number
    isUnread: number
    rawJson: number
    _all: number
  }


  export type EmailItemMinAggregateInputType = {
    id?: true
    userId?: true
    gmailId?: true
    threadId?: true
    from?: true
    subject?: true
    snippet?: true
    receivedAt?: true
    isUnread?: true
    rawJson?: true
  }

  export type EmailItemMaxAggregateInputType = {
    id?: true
    userId?: true
    gmailId?: true
    threadId?: true
    from?: true
    subject?: true
    snippet?: true
    receivedAt?: true
    isUnread?: true
    rawJson?: true
  }

  export type EmailItemCountAggregateInputType = {
    id?: true
    userId?: true
    gmailId?: true
    threadId?: true
    from?: true
    subject?: true
    snippet?: true
    receivedAt?: true
    isUnread?: true
    rawJson?: true
    _all?: true
  }

  export type EmailItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailItem to aggregate.
     */
    where?: EmailItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailItems to fetch.
     */
    orderBy?: EmailItemOrderByWithRelationInput | EmailItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailItems
    **/
    _count?: true | EmailItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailItemMaxAggregateInputType
  }

  export type GetEmailItemAggregateType<T extends EmailItemAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailItem[P]>
      : GetScalarType<T[P], AggregateEmailItem[P]>
  }




  export type EmailItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailItemWhereInput
    orderBy?: EmailItemOrderByWithAggregationInput | EmailItemOrderByWithAggregationInput[]
    by: EmailItemScalarFieldEnum[] | EmailItemScalarFieldEnum
    having?: EmailItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailItemCountAggregateInputType | true
    _min?: EmailItemMinAggregateInputType
    _max?: EmailItemMaxAggregateInputType
  }

  export type EmailItemGroupByOutputType = {
    id: string
    userId: string
    gmailId: string
    threadId: string | null
    from: string
    subject: string
    snippet: string
    receivedAt: Date
    isUnread: boolean
    rawJson: string
    _count: EmailItemCountAggregateOutputType | null
    _min: EmailItemMinAggregateOutputType | null
    _max: EmailItemMaxAggregateOutputType | null
  }

  type GetEmailItemGroupByPayload<T extends EmailItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailItemGroupByOutputType[P]>
            : GetScalarType<T[P], EmailItemGroupByOutputType[P]>
        }
      >
    >


  export type EmailItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gmailId?: boolean
    threadId?: boolean
    from?: boolean
    subject?: boolean
    snippet?: boolean
    receivedAt?: boolean
    isUnread?: boolean
    rawJson?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailItem"]>

  export type EmailItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gmailId?: boolean
    threadId?: boolean
    from?: boolean
    subject?: boolean
    snippet?: boolean
    receivedAt?: boolean
    isUnread?: boolean
    rawJson?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailItem"]>

  export type EmailItemSelectScalar = {
    id?: boolean
    userId?: boolean
    gmailId?: boolean
    threadId?: boolean
    from?: boolean
    subject?: boolean
    snippet?: boolean
    receivedAt?: boolean
    isUnread?: boolean
    rawJson?: boolean
  }

  export type EmailItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailItem"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      gmailId: string
      threadId: string | null
      from: string
      subject: string
      snippet: string
      receivedAt: Date
      isUnread: boolean
      rawJson: string
    }, ExtArgs["result"]["emailItem"]>
    composites: {}
  }

  type EmailItemGetPayload<S extends boolean | null | undefined | EmailItemDefaultArgs> = $Result.GetResult<Prisma.$EmailItemPayload, S>

  type EmailItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailItemCountAggregateInputType | true
    }

  export interface EmailItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailItem'], meta: { name: 'EmailItem' } }
    /**
     * Find zero or one EmailItem that matches the filter.
     * @param {EmailItemFindUniqueArgs} args - Arguments to find a EmailItem
     * @example
     * // Get one EmailItem
     * const emailItem = await prisma.emailItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailItemFindUniqueArgs>(args: SelectSubset<T, EmailItemFindUniqueArgs<ExtArgs>>): Prisma__EmailItemClient<$Result.GetResult<Prisma.$EmailItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailItemFindUniqueOrThrowArgs} args - Arguments to find a EmailItem
     * @example
     * // Get one EmailItem
     * const emailItem = await prisma.emailItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailItemFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailItemClient<$Result.GetResult<Prisma.$EmailItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailItemFindFirstArgs} args - Arguments to find a EmailItem
     * @example
     * // Get one EmailItem
     * const emailItem = await prisma.emailItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailItemFindFirstArgs>(args?: SelectSubset<T, EmailItemFindFirstArgs<ExtArgs>>): Prisma__EmailItemClient<$Result.GetResult<Prisma.$EmailItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailItemFindFirstOrThrowArgs} args - Arguments to find a EmailItem
     * @example
     * // Get one EmailItem
     * const emailItem = await prisma.emailItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailItemFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailItemClient<$Result.GetResult<Prisma.$EmailItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailItems
     * const emailItems = await prisma.emailItem.findMany()
     * 
     * // Get first 10 EmailItems
     * const emailItems = await prisma.emailItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailItemWithIdOnly = await prisma.emailItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailItemFindManyArgs>(args?: SelectSubset<T, EmailItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailItem.
     * @param {EmailItemCreateArgs} args - Arguments to create a EmailItem.
     * @example
     * // Create one EmailItem
     * const EmailItem = await prisma.emailItem.create({
     *   data: {
     *     // ... data to create a EmailItem
     *   }
     * })
     * 
     */
    create<T extends EmailItemCreateArgs>(args: SelectSubset<T, EmailItemCreateArgs<ExtArgs>>): Prisma__EmailItemClient<$Result.GetResult<Prisma.$EmailItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailItems.
     * @param {EmailItemCreateManyArgs} args - Arguments to create many EmailItems.
     * @example
     * // Create many EmailItems
     * const emailItem = await prisma.emailItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailItemCreateManyArgs>(args?: SelectSubset<T, EmailItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailItems and returns the data saved in the database.
     * @param {EmailItemCreateManyAndReturnArgs} args - Arguments to create many EmailItems.
     * @example
     * // Create many EmailItems
     * const emailItem = await prisma.emailItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailItems and only return the `id`
     * const emailItemWithIdOnly = await prisma.emailItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailItemCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailItem.
     * @param {EmailItemDeleteArgs} args - Arguments to delete one EmailItem.
     * @example
     * // Delete one EmailItem
     * const EmailItem = await prisma.emailItem.delete({
     *   where: {
     *     // ... filter to delete one EmailItem
     *   }
     * })
     * 
     */
    delete<T extends EmailItemDeleteArgs>(args: SelectSubset<T, EmailItemDeleteArgs<ExtArgs>>): Prisma__EmailItemClient<$Result.GetResult<Prisma.$EmailItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailItem.
     * @param {EmailItemUpdateArgs} args - Arguments to update one EmailItem.
     * @example
     * // Update one EmailItem
     * const emailItem = await prisma.emailItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailItemUpdateArgs>(args: SelectSubset<T, EmailItemUpdateArgs<ExtArgs>>): Prisma__EmailItemClient<$Result.GetResult<Prisma.$EmailItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailItems.
     * @param {EmailItemDeleteManyArgs} args - Arguments to filter EmailItems to delete.
     * @example
     * // Delete a few EmailItems
     * const { count } = await prisma.emailItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailItemDeleteManyArgs>(args?: SelectSubset<T, EmailItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailItems
     * const emailItem = await prisma.emailItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailItemUpdateManyArgs>(args: SelectSubset<T, EmailItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailItem.
     * @param {EmailItemUpsertArgs} args - Arguments to update or create a EmailItem.
     * @example
     * // Update or create a EmailItem
     * const emailItem = await prisma.emailItem.upsert({
     *   create: {
     *     // ... data to create a EmailItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailItem we want to update
     *   }
     * })
     */
    upsert<T extends EmailItemUpsertArgs>(args: SelectSubset<T, EmailItemUpsertArgs<ExtArgs>>): Prisma__EmailItemClient<$Result.GetResult<Prisma.$EmailItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailItemCountArgs} args - Arguments to filter EmailItems to count.
     * @example
     * // Count the number of EmailItems
     * const count = await prisma.emailItem.count({
     *   where: {
     *     // ... the filter for the EmailItems we want to count
     *   }
     * })
    **/
    count<T extends EmailItemCountArgs>(
      args?: Subset<T, EmailItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailItemAggregateArgs>(args: Subset<T, EmailItemAggregateArgs>): Prisma.PrismaPromise<GetEmailItemAggregateType<T>>

    /**
     * Group by EmailItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailItemGroupByArgs['orderBy'] }
        : { orderBy?: EmailItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailItem model
   */
  readonly fields: EmailItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailItem model
   */ 
  interface EmailItemFieldRefs {
    readonly id: FieldRef<"EmailItem", 'String'>
    readonly userId: FieldRef<"EmailItem", 'String'>
    readonly gmailId: FieldRef<"EmailItem", 'String'>
    readonly threadId: FieldRef<"EmailItem", 'String'>
    readonly from: FieldRef<"EmailItem", 'String'>
    readonly subject: FieldRef<"EmailItem", 'String'>
    readonly snippet: FieldRef<"EmailItem", 'String'>
    readonly receivedAt: FieldRef<"EmailItem", 'DateTime'>
    readonly isUnread: FieldRef<"EmailItem", 'Boolean'>
    readonly rawJson: FieldRef<"EmailItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailItem findUnique
   */
  export type EmailItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailItem
     */
    select?: EmailItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailItemInclude<ExtArgs> | null
    /**
     * Filter, which EmailItem to fetch.
     */
    where: EmailItemWhereUniqueInput
  }

  /**
   * EmailItem findUniqueOrThrow
   */
  export type EmailItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailItem
     */
    select?: EmailItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailItemInclude<ExtArgs> | null
    /**
     * Filter, which EmailItem to fetch.
     */
    where: EmailItemWhereUniqueInput
  }

  /**
   * EmailItem findFirst
   */
  export type EmailItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailItem
     */
    select?: EmailItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailItemInclude<ExtArgs> | null
    /**
     * Filter, which EmailItem to fetch.
     */
    where?: EmailItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailItems to fetch.
     */
    orderBy?: EmailItemOrderByWithRelationInput | EmailItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailItems.
     */
    cursor?: EmailItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailItems.
     */
    distinct?: EmailItemScalarFieldEnum | EmailItemScalarFieldEnum[]
  }

  /**
   * EmailItem findFirstOrThrow
   */
  export type EmailItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailItem
     */
    select?: EmailItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailItemInclude<ExtArgs> | null
    /**
     * Filter, which EmailItem to fetch.
     */
    where?: EmailItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailItems to fetch.
     */
    orderBy?: EmailItemOrderByWithRelationInput | EmailItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailItems.
     */
    cursor?: EmailItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailItems.
     */
    distinct?: EmailItemScalarFieldEnum | EmailItemScalarFieldEnum[]
  }

  /**
   * EmailItem findMany
   */
  export type EmailItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailItem
     */
    select?: EmailItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailItemInclude<ExtArgs> | null
    /**
     * Filter, which EmailItems to fetch.
     */
    where?: EmailItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailItems to fetch.
     */
    orderBy?: EmailItemOrderByWithRelationInput | EmailItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailItems.
     */
    cursor?: EmailItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailItems.
     */
    skip?: number
    distinct?: EmailItemScalarFieldEnum | EmailItemScalarFieldEnum[]
  }

  /**
   * EmailItem create
   */
  export type EmailItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailItem
     */
    select?: EmailItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailItemInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailItem.
     */
    data: XOR<EmailItemCreateInput, EmailItemUncheckedCreateInput>
  }

  /**
   * EmailItem createMany
   */
  export type EmailItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailItems.
     */
    data: EmailItemCreateManyInput | EmailItemCreateManyInput[]
  }

  /**
   * EmailItem createManyAndReturn
   */
  export type EmailItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailItem
     */
    select?: EmailItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailItems.
     */
    data: EmailItemCreateManyInput | EmailItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailItem update
   */
  export type EmailItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailItem
     */
    select?: EmailItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailItemInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailItem.
     */
    data: XOR<EmailItemUpdateInput, EmailItemUncheckedUpdateInput>
    /**
     * Choose, which EmailItem to update.
     */
    where: EmailItemWhereUniqueInput
  }

  /**
   * EmailItem updateMany
   */
  export type EmailItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailItems.
     */
    data: XOR<EmailItemUpdateManyMutationInput, EmailItemUncheckedUpdateManyInput>
    /**
     * Filter which EmailItems to update
     */
    where?: EmailItemWhereInput
  }

  /**
   * EmailItem upsert
   */
  export type EmailItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailItem
     */
    select?: EmailItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailItemInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailItem to update in case it exists.
     */
    where: EmailItemWhereUniqueInput
    /**
     * In case the EmailItem found by the `where` argument doesn't exist, create a new EmailItem with this data.
     */
    create: XOR<EmailItemCreateInput, EmailItemUncheckedCreateInput>
    /**
     * In case the EmailItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailItemUpdateInput, EmailItemUncheckedUpdateInput>
  }

  /**
   * EmailItem delete
   */
  export type EmailItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailItem
     */
    select?: EmailItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailItemInclude<ExtArgs> | null
    /**
     * Filter which EmailItem to delete.
     */
    where: EmailItemWhereUniqueInput
  }

  /**
   * EmailItem deleteMany
   */
  export type EmailItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailItems to delete
     */
    where?: EmailItemWhereInput
  }

  /**
   * EmailItem without action
   */
  export type EmailItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailItem
     */
    select?: EmailItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailItemInclude<ExtArgs> | null
  }


  /**
   * Model CalendarEvent
   */

  export type AggregateCalendarEvent = {
    _count: CalendarEventCountAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  export type CalendarEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    gcalId: string | null
    title: string | null
    start: Date | null
    end: Date | null
    location: string | null
    rawJson: string | null
  }

  export type CalendarEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    gcalId: string | null
    title: string | null
    start: Date | null
    end: Date | null
    location: string | null
    rawJson: string | null
  }

  export type CalendarEventCountAggregateOutputType = {
    id: number
    userId: number
    gcalId: number
    title: number
    start: number
    end: number
    location: number
    rawJson: number
    _all: number
  }


  export type CalendarEventMinAggregateInputType = {
    id?: true
    userId?: true
    gcalId?: true
    title?: true
    start?: true
    end?: true
    location?: true
    rawJson?: true
  }

  export type CalendarEventMaxAggregateInputType = {
    id?: true
    userId?: true
    gcalId?: true
    title?: true
    start?: true
    end?: true
    location?: true
    rawJson?: true
  }

  export type CalendarEventCountAggregateInputType = {
    id?: true
    userId?: true
    gcalId?: true
    title?: true
    start?: true
    end?: true
    location?: true
    rawJson?: true
    _all?: true
  }

  export type CalendarEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvent to aggregate.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEvents
    **/
    _count?: true | CalendarEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventMaxAggregateInputType
  }

  export type GetCalendarEventAggregateType<T extends CalendarEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEvent[P]>
      : GetScalarType<T[P], AggregateCalendarEvent[P]>
  }




  export type CalendarEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithAggregationInput | CalendarEventOrderByWithAggregationInput[]
    by: CalendarEventScalarFieldEnum[] | CalendarEventScalarFieldEnum
    having?: CalendarEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventCountAggregateInputType | true
    _min?: CalendarEventMinAggregateInputType
    _max?: CalendarEventMaxAggregateInputType
  }

  export type CalendarEventGroupByOutputType = {
    id: string
    userId: string
    gcalId: string
    title: string
    start: Date
    end: Date
    location: string | null
    rawJson: string
    _count: CalendarEventCountAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  type GetCalendarEventGroupByPayload<T extends CalendarEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gcalId?: boolean
    title?: boolean
    start?: boolean
    end?: boolean
    location?: boolean
    rawJson?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gcalId?: boolean
    title?: boolean
    start?: boolean
    end?: boolean
    location?: boolean
    rawJson?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectScalar = {
    id?: boolean
    userId?: boolean
    gcalId?: boolean
    title?: boolean
    start?: boolean
    end?: boolean
    location?: boolean
    rawJson?: boolean
  }

  export type CalendarEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CalendarEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CalendarEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      gcalId: string
      title: string
      start: Date
      end: Date
      location: string | null
      rawJson: string
    }, ExtArgs["result"]["calendarEvent"]>
    composites: {}
  }

  type CalendarEventGetPayload<S extends boolean | null | undefined | CalendarEventDefaultArgs> = $Result.GetResult<Prisma.$CalendarEventPayload, S>

  type CalendarEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CalendarEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CalendarEventCountAggregateInputType | true
    }

  export interface CalendarEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEvent'], meta: { name: 'CalendarEvent' } }
    /**
     * Find zero or one CalendarEvent that matches the filter.
     * @param {CalendarEventFindUniqueArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEventFindUniqueArgs>(args: SelectSubset<T, CalendarEventFindUniqueArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CalendarEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CalendarEventFindUniqueOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CalendarEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEventFindFirstArgs>(args?: SelectSubset<T, CalendarEventFindFirstArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CalendarEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CalendarEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany()
     * 
     * // Get first 10 CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEventFindManyArgs>(args?: SelectSubset<T, CalendarEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CalendarEvent.
     * @param {CalendarEventCreateArgs} args - Arguments to create a CalendarEvent.
     * @example
     * // Create one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.create({
     *   data: {
     *     // ... data to create a CalendarEvent
     *   }
     * })
     * 
     */
    create<T extends CalendarEventCreateArgs>(args: SelectSubset<T, CalendarEventCreateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CalendarEvents.
     * @param {CalendarEventCreateManyArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEventCreateManyArgs>(args?: SelectSubset<T, CalendarEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarEvents and returns the data saved in the database.
     * @param {CalendarEventCreateManyAndReturnArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarEvents and only return the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarEventCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CalendarEvent.
     * @param {CalendarEventDeleteArgs} args - Arguments to delete one CalendarEvent.
     * @example
     * // Delete one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.delete({
     *   where: {
     *     // ... filter to delete one CalendarEvent
     *   }
     * })
     * 
     */
    delete<T extends CalendarEventDeleteArgs>(args: SelectSubset<T, CalendarEventDeleteArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CalendarEvent.
     * @param {CalendarEventUpdateArgs} args - Arguments to update one CalendarEvent.
     * @example
     * // Update one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEventUpdateArgs>(args: SelectSubset<T, CalendarEventUpdateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CalendarEvents.
     * @param {CalendarEventDeleteManyArgs} args - Arguments to filter CalendarEvents to delete.
     * @example
     * // Delete a few CalendarEvents
     * const { count } = await prisma.calendarEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEventDeleteManyArgs>(args?: SelectSubset<T, CalendarEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEventUpdateManyArgs>(args: SelectSubset<T, CalendarEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarEvent.
     * @param {CalendarEventUpsertArgs} args - Arguments to update or create a CalendarEvent.
     * @example
     * // Update or create a CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.upsert({
     *   create: {
     *     // ... data to create a CalendarEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEvent we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEventUpsertArgs>(args: SelectSubset<T, CalendarEventUpsertArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventCountArgs} args - Arguments to filter CalendarEvents to count.
     * @example
     * // Count the number of CalendarEvents
     * const count = await prisma.calendarEvent.count({
     *   where: {
     *     // ... the filter for the CalendarEvents we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventCountArgs>(
      args?: Subset<T, CalendarEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventAggregateArgs>(args: Subset<T, CalendarEventAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventAggregateType<T>>

    /**
     * Group by CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEvent model
   */
  readonly fields: CalendarEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEvent model
   */ 
  interface CalendarEventFieldRefs {
    readonly id: FieldRef<"CalendarEvent", 'String'>
    readonly userId: FieldRef<"CalendarEvent", 'String'>
    readonly gcalId: FieldRef<"CalendarEvent", 'String'>
    readonly title: FieldRef<"CalendarEvent", 'String'>
    readonly start: FieldRef<"CalendarEvent", 'DateTime'>
    readonly end: FieldRef<"CalendarEvent", 'DateTime'>
    readonly location: FieldRef<"CalendarEvent", 'String'>
    readonly rawJson: FieldRef<"CalendarEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEvent findUnique
   */
  export type CalendarEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findUniqueOrThrow
   */
  export type CalendarEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findFirst
   */
  export type CalendarEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findFirstOrThrow
   */
  export type CalendarEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findMany
   */
  export type CalendarEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvents to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent create
   */
  export type CalendarEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarEvent.
     */
    data: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
  }

  /**
   * CalendarEvent createMany
   */
  export type CalendarEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
  }

  /**
   * CalendarEvent createManyAndReturn
   */
  export type CalendarEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEvent update
   */
  export type CalendarEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarEvent.
     */
    data: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
    /**
     * Choose, which CalendarEvent to update.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent updateMany
   */
  export type CalendarEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEvents.
     */
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEvents to update
     */
    where?: CalendarEventWhereInput
  }

  /**
   * CalendarEvent upsert
   */
  export type CalendarEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarEvent to update in case it exists.
     */
    where: CalendarEventWhereUniqueInput
    /**
     * In case the CalendarEvent found by the `where` argument doesn't exist, create a new CalendarEvent with this data.
     */
    create: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
    /**
     * In case the CalendarEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
  }

  /**
   * CalendarEvent delete
   */
  export type CalendarEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter which CalendarEvent to delete.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent deleteMany
   */
  export type CalendarEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvents to delete
     */
    where?: CalendarEventWhereInput
  }

  /**
   * CalendarEvent without action
   */
  export type CalendarEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
  }


  /**
   * Model DocItem
   */

  export type AggregateDocItem = {
    _count: DocItemCountAggregateOutputType | null
    _min: DocItemMinAggregateOutputType | null
    _max: DocItemMaxAggregateOutputType | null
  }

  export type DocItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fileId: string | null
    title: string | null
    sourceType: string | null
    modifiedTime: Date | null
    extractedText: string | null
    textHash: string | null
    rawJson: string | null
  }

  export type DocItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fileId: string | null
    title: string | null
    sourceType: string | null
    modifiedTime: Date | null
    extractedText: string | null
    textHash: string | null
    rawJson: string | null
  }

  export type DocItemCountAggregateOutputType = {
    id: number
    userId: number
    fileId: number
    title: number
    sourceType: number
    modifiedTime: number
    extractedText: number
    textHash: number
    rawJson: number
    _all: number
  }


  export type DocItemMinAggregateInputType = {
    id?: true
    userId?: true
    fileId?: true
    title?: true
    sourceType?: true
    modifiedTime?: true
    extractedText?: true
    textHash?: true
    rawJson?: true
  }

  export type DocItemMaxAggregateInputType = {
    id?: true
    userId?: true
    fileId?: true
    title?: true
    sourceType?: true
    modifiedTime?: true
    extractedText?: true
    textHash?: true
    rawJson?: true
  }

  export type DocItemCountAggregateInputType = {
    id?: true
    userId?: true
    fileId?: true
    title?: true
    sourceType?: true
    modifiedTime?: true
    extractedText?: true
    textHash?: true
    rawJson?: true
    _all?: true
  }

  export type DocItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocItem to aggregate.
     */
    where?: DocItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocItems to fetch.
     */
    orderBy?: DocItemOrderByWithRelationInput | DocItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocItems
    **/
    _count?: true | DocItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocItemMaxAggregateInputType
  }

  export type GetDocItemAggregateType<T extends DocItemAggregateArgs> = {
        [P in keyof T & keyof AggregateDocItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocItem[P]>
      : GetScalarType<T[P], AggregateDocItem[P]>
  }




  export type DocItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocItemWhereInput
    orderBy?: DocItemOrderByWithAggregationInput | DocItemOrderByWithAggregationInput[]
    by: DocItemScalarFieldEnum[] | DocItemScalarFieldEnum
    having?: DocItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocItemCountAggregateInputType | true
    _min?: DocItemMinAggregateInputType
    _max?: DocItemMaxAggregateInputType
  }

  export type DocItemGroupByOutputType = {
    id: string
    userId: string
    fileId: string
    title: string
    sourceType: string
    modifiedTime: Date
    extractedText: string | null
    textHash: string | null
    rawJson: string
    _count: DocItemCountAggregateOutputType | null
    _min: DocItemMinAggregateOutputType | null
    _max: DocItemMaxAggregateOutputType | null
  }

  type GetDocItemGroupByPayload<T extends DocItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocItemGroupByOutputType[P]>
            : GetScalarType<T[P], DocItemGroupByOutputType[P]>
        }
      >
    >


  export type DocItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fileId?: boolean
    title?: boolean
    sourceType?: boolean
    modifiedTime?: boolean
    extractedText?: boolean
    textHash?: boolean
    rawJson?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["docItem"]>

  export type DocItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fileId?: boolean
    title?: boolean
    sourceType?: boolean
    modifiedTime?: boolean
    extractedText?: boolean
    textHash?: boolean
    rawJson?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["docItem"]>

  export type DocItemSelectScalar = {
    id?: boolean
    userId?: boolean
    fileId?: boolean
    title?: boolean
    sourceType?: boolean
    modifiedTime?: boolean
    extractedText?: boolean
    textHash?: boolean
    rawJson?: boolean
  }

  export type DocItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocItem"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      fileId: string
      title: string
      sourceType: string
      modifiedTime: Date
      extractedText: string | null
      textHash: string | null
      rawJson: string
    }, ExtArgs["result"]["docItem"]>
    composites: {}
  }

  type DocItemGetPayload<S extends boolean | null | undefined | DocItemDefaultArgs> = $Result.GetResult<Prisma.$DocItemPayload, S>

  type DocItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocItemCountAggregateInputType | true
    }

  export interface DocItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocItem'], meta: { name: 'DocItem' } }
    /**
     * Find zero or one DocItem that matches the filter.
     * @param {DocItemFindUniqueArgs} args - Arguments to find a DocItem
     * @example
     * // Get one DocItem
     * const docItem = await prisma.docItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocItemFindUniqueArgs>(args: SelectSubset<T, DocItemFindUniqueArgs<ExtArgs>>): Prisma__DocItemClient<$Result.GetResult<Prisma.$DocItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocItemFindUniqueOrThrowArgs} args - Arguments to find a DocItem
     * @example
     * // Get one DocItem
     * const docItem = await prisma.docItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocItemFindUniqueOrThrowArgs>(args: SelectSubset<T, DocItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocItemClient<$Result.GetResult<Prisma.$DocItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocItemFindFirstArgs} args - Arguments to find a DocItem
     * @example
     * // Get one DocItem
     * const docItem = await prisma.docItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocItemFindFirstArgs>(args?: SelectSubset<T, DocItemFindFirstArgs<ExtArgs>>): Prisma__DocItemClient<$Result.GetResult<Prisma.$DocItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocItemFindFirstOrThrowArgs} args - Arguments to find a DocItem
     * @example
     * // Get one DocItem
     * const docItem = await prisma.docItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocItemFindFirstOrThrowArgs>(args?: SelectSubset<T, DocItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocItemClient<$Result.GetResult<Prisma.$DocItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocItems
     * const docItems = await prisma.docItem.findMany()
     * 
     * // Get first 10 DocItems
     * const docItems = await prisma.docItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const docItemWithIdOnly = await prisma.docItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocItemFindManyArgs>(args?: SelectSubset<T, DocItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocItem.
     * @param {DocItemCreateArgs} args - Arguments to create a DocItem.
     * @example
     * // Create one DocItem
     * const DocItem = await prisma.docItem.create({
     *   data: {
     *     // ... data to create a DocItem
     *   }
     * })
     * 
     */
    create<T extends DocItemCreateArgs>(args: SelectSubset<T, DocItemCreateArgs<ExtArgs>>): Prisma__DocItemClient<$Result.GetResult<Prisma.$DocItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocItems.
     * @param {DocItemCreateManyArgs} args - Arguments to create many DocItems.
     * @example
     * // Create many DocItems
     * const docItem = await prisma.docItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocItemCreateManyArgs>(args?: SelectSubset<T, DocItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocItems and returns the data saved in the database.
     * @param {DocItemCreateManyAndReturnArgs} args - Arguments to create many DocItems.
     * @example
     * // Create many DocItems
     * const docItem = await prisma.docItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocItems and only return the `id`
     * const docItemWithIdOnly = await prisma.docItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocItemCreateManyAndReturnArgs>(args?: SelectSubset<T, DocItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DocItem.
     * @param {DocItemDeleteArgs} args - Arguments to delete one DocItem.
     * @example
     * // Delete one DocItem
     * const DocItem = await prisma.docItem.delete({
     *   where: {
     *     // ... filter to delete one DocItem
     *   }
     * })
     * 
     */
    delete<T extends DocItemDeleteArgs>(args: SelectSubset<T, DocItemDeleteArgs<ExtArgs>>): Prisma__DocItemClient<$Result.GetResult<Prisma.$DocItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocItem.
     * @param {DocItemUpdateArgs} args - Arguments to update one DocItem.
     * @example
     * // Update one DocItem
     * const docItem = await prisma.docItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocItemUpdateArgs>(args: SelectSubset<T, DocItemUpdateArgs<ExtArgs>>): Prisma__DocItemClient<$Result.GetResult<Prisma.$DocItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocItems.
     * @param {DocItemDeleteManyArgs} args - Arguments to filter DocItems to delete.
     * @example
     * // Delete a few DocItems
     * const { count } = await prisma.docItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocItemDeleteManyArgs>(args?: SelectSubset<T, DocItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocItems
     * const docItem = await prisma.docItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocItemUpdateManyArgs>(args: SelectSubset<T, DocItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocItem.
     * @param {DocItemUpsertArgs} args - Arguments to update or create a DocItem.
     * @example
     * // Update or create a DocItem
     * const docItem = await prisma.docItem.upsert({
     *   create: {
     *     // ... data to create a DocItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocItem we want to update
     *   }
     * })
     */
    upsert<T extends DocItemUpsertArgs>(args: SelectSubset<T, DocItemUpsertArgs<ExtArgs>>): Prisma__DocItemClient<$Result.GetResult<Prisma.$DocItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DocItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocItemCountArgs} args - Arguments to filter DocItems to count.
     * @example
     * // Count the number of DocItems
     * const count = await prisma.docItem.count({
     *   where: {
     *     // ... the filter for the DocItems we want to count
     *   }
     * })
    **/
    count<T extends DocItemCountArgs>(
      args?: Subset<T, DocItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocItemAggregateArgs>(args: Subset<T, DocItemAggregateArgs>): Prisma.PrismaPromise<GetDocItemAggregateType<T>>

    /**
     * Group by DocItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocItemGroupByArgs['orderBy'] }
        : { orderBy?: DocItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocItem model
   */
  readonly fields: DocItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocItem model
   */ 
  interface DocItemFieldRefs {
    readonly id: FieldRef<"DocItem", 'String'>
    readonly userId: FieldRef<"DocItem", 'String'>
    readonly fileId: FieldRef<"DocItem", 'String'>
    readonly title: FieldRef<"DocItem", 'String'>
    readonly sourceType: FieldRef<"DocItem", 'String'>
    readonly modifiedTime: FieldRef<"DocItem", 'DateTime'>
    readonly extractedText: FieldRef<"DocItem", 'String'>
    readonly textHash: FieldRef<"DocItem", 'String'>
    readonly rawJson: FieldRef<"DocItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocItem findUnique
   */
  export type DocItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocItem
     */
    select?: DocItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocItemInclude<ExtArgs> | null
    /**
     * Filter, which DocItem to fetch.
     */
    where: DocItemWhereUniqueInput
  }

  /**
   * DocItem findUniqueOrThrow
   */
  export type DocItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocItem
     */
    select?: DocItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocItemInclude<ExtArgs> | null
    /**
     * Filter, which DocItem to fetch.
     */
    where: DocItemWhereUniqueInput
  }

  /**
   * DocItem findFirst
   */
  export type DocItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocItem
     */
    select?: DocItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocItemInclude<ExtArgs> | null
    /**
     * Filter, which DocItem to fetch.
     */
    where?: DocItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocItems to fetch.
     */
    orderBy?: DocItemOrderByWithRelationInput | DocItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocItems.
     */
    cursor?: DocItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocItems.
     */
    distinct?: DocItemScalarFieldEnum | DocItemScalarFieldEnum[]
  }

  /**
   * DocItem findFirstOrThrow
   */
  export type DocItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocItem
     */
    select?: DocItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocItemInclude<ExtArgs> | null
    /**
     * Filter, which DocItem to fetch.
     */
    where?: DocItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocItems to fetch.
     */
    orderBy?: DocItemOrderByWithRelationInput | DocItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocItems.
     */
    cursor?: DocItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocItems.
     */
    distinct?: DocItemScalarFieldEnum | DocItemScalarFieldEnum[]
  }

  /**
   * DocItem findMany
   */
  export type DocItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocItem
     */
    select?: DocItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocItemInclude<ExtArgs> | null
    /**
     * Filter, which DocItems to fetch.
     */
    where?: DocItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocItems to fetch.
     */
    orderBy?: DocItemOrderByWithRelationInput | DocItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocItems.
     */
    cursor?: DocItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocItems.
     */
    skip?: number
    distinct?: DocItemScalarFieldEnum | DocItemScalarFieldEnum[]
  }

  /**
   * DocItem create
   */
  export type DocItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocItem
     */
    select?: DocItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocItemInclude<ExtArgs> | null
    /**
     * The data needed to create a DocItem.
     */
    data: XOR<DocItemCreateInput, DocItemUncheckedCreateInput>
  }

  /**
   * DocItem createMany
   */
  export type DocItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocItems.
     */
    data: DocItemCreateManyInput | DocItemCreateManyInput[]
  }

  /**
   * DocItem createManyAndReturn
   */
  export type DocItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocItem
     */
    select?: DocItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DocItems.
     */
    data: DocItemCreateManyInput | DocItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocItem update
   */
  export type DocItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocItem
     */
    select?: DocItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocItemInclude<ExtArgs> | null
    /**
     * The data needed to update a DocItem.
     */
    data: XOR<DocItemUpdateInput, DocItemUncheckedUpdateInput>
    /**
     * Choose, which DocItem to update.
     */
    where: DocItemWhereUniqueInput
  }

  /**
   * DocItem updateMany
   */
  export type DocItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocItems.
     */
    data: XOR<DocItemUpdateManyMutationInput, DocItemUncheckedUpdateManyInput>
    /**
     * Filter which DocItems to update
     */
    where?: DocItemWhereInput
  }

  /**
   * DocItem upsert
   */
  export type DocItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocItem
     */
    select?: DocItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocItemInclude<ExtArgs> | null
    /**
     * The filter to search for the DocItem to update in case it exists.
     */
    where: DocItemWhereUniqueInput
    /**
     * In case the DocItem found by the `where` argument doesn't exist, create a new DocItem with this data.
     */
    create: XOR<DocItemCreateInput, DocItemUncheckedCreateInput>
    /**
     * In case the DocItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocItemUpdateInput, DocItemUncheckedUpdateInput>
  }

  /**
   * DocItem delete
   */
  export type DocItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocItem
     */
    select?: DocItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocItemInclude<ExtArgs> | null
    /**
     * Filter which DocItem to delete.
     */
    where: DocItemWhereUniqueInput
  }

  /**
   * DocItem deleteMany
   */
  export type DocItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocItems to delete
     */
    where?: DocItemWhereInput
  }

  /**
   * DocItem without action
   */
  export type DocItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocItem
     */
    select?: DocItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocItemInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    estMins: number | null
  }

  export type TaskSumAggregateOutputType = {
    estMins: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    sourceType: string | null
    sourceId: string | null
    dueAt: Date | null
    estMins: number | null
    priority: string | null
    status: string | null
    createdAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    sourceType: string | null
    sourceId: string | null
    dueAt: Date | null
    estMins: number | null
    priority: string | null
    status: string | null
    createdAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    sourceType: number
    sourceId: number
    dueAt: number
    estMins: number
    priority: number
    status: number
    createdAt: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    estMins?: true
  }

  export type TaskSumAggregateInputType = {
    estMins?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    sourceType?: true
    sourceId?: true
    dueAt?: true
    estMins?: true
    priority?: true
    status?: true
    createdAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    sourceType?: true
    sourceId?: true
    dueAt?: true
    estMins?: true
    priority?: true
    status?: true
    createdAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    sourceType?: true
    sourceId?: true
    dueAt?: true
    estMins?: true
    priority?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    sourceType: string
    sourceId: string | null
    dueAt: Date | null
    estMins: number | null
    priority: string
    status: string
    createdAt: Date
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    sourceType?: boolean
    sourceId?: boolean
    dueAt?: boolean
    estMins?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    sourceType?: boolean
    sourceId?: boolean
    dueAt?: boolean
    estMins?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    sourceType?: boolean
    sourceId?: boolean
    dueAt?: boolean
    estMins?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      sourceType: string
      sourceId: string | null
      dueAt: Date | null
      estMins: number | null
      priority: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly userId: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly sourceType: FieldRef<"Task", 'String'>
    readonly sourceId: FieldRef<"Task", 'String'>
    readonly dueAt: FieldRef<"Task", 'DateTime'>
    readonly estMins: FieldRef<"Task", 'Int'>
    readonly priority: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    userId: string | null
    weekStartDate: Date | null
    planJson: string | null
    createdAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    weekStartDate: Date | null
    planJson: string | null
    createdAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    userId: number
    weekStartDate: number
    planJson: number
    createdAt: number
    _all: number
  }


  export type PlanMinAggregateInputType = {
    id?: true
    userId?: true
    weekStartDate?: true
    planJson?: true
    createdAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    userId?: true
    weekStartDate?: true
    planJson?: true
    createdAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    userId?: true
    weekStartDate?: true
    planJson?: true
    createdAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    userId: string
    weekStartDate: Date
    planJson: string
    createdAt: Date
    _count: PlanCountAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    weekStartDate?: boolean
    planJson?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    weekStartDate?: boolean
    planJson?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    userId?: boolean
    weekStartDate?: boolean
    planJson?: boolean
    createdAt?: boolean
  }

  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      weekStartDate: Date
      planJson: string
      createdAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */ 
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly userId: FieldRef<"Plan", 'String'>
    readonly weekStartDate: FieldRef<"Plan", 'DateTime'>
    readonly planJson: FieldRef<"Plan", 'String'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model TriageRun
   */

  export type AggregateTriageRun = {
    _count: TriageRunCountAggregateOutputType | null
    _min: TriageRunMinAggregateOutputType | null
    _max: TriageRunMaxAggregateOutputType | null
  }

  export type TriageRunMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    resultJson: string | null
  }

  export type TriageRunMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    resultJson: string | null
  }

  export type TriageRunCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    resultJson: number
    _all: number
  }


  export type TriageRunMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    resultJson?: true
  }

  export type TriageRunMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    resultJson?: true
  }

  export type TriageRunCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    resultJson?: true
    _all?: true
  }

  export type TriageRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TriageRun to aggregate.
     */
    where?: TriageRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriageRuns to fetch.
     */
    orderBy?: TriageRunOrderByWithRelationInput | TriageRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriageRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriageRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriageRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TriageRuns
    **/
    _count?: true | TriageRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriageRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriageRunMaxAggregateInputType
  }

  export type GetTriageRunAggregateType<T extends TriageRunAggregateArgs> = {
        [P in keyof T & keyof AggregateTriageRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTriageRun[P]>
      : GetScalarType<T[P], AggregateTriageRun[P]>
  }




  export type TriageRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriageRunWhereInput
    orderBy?: TriageRunOrderByWithAggregationInput | TriageRunOrderByWithAggregationInput[]
    by: TriageRunScalarFieldEnum[] | TriageRunScalarFieldEnum
    having?: TriageRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriageRunCountAggregateInputType | true
    _min?: TriageRunMinAggregateInputType
    _max?: TriageRunMaxAggregateInputType
  }

  export type TriageRunGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    resultJson: string
    _count: TriageRunCountAggregateOutputType | null
    _min: TriageRunMinAggregateOutputType | null
    _max: TriageRunMaxAggregateOutputType | null
  }

  type GetTriageRunGroupByPayload<T extends TriageRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TriageRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriageRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriageRunGroupByOutputType[P]>
            : GetScalarType<T[P], TriageRunGroupByOutputType[P]>
        }
      >
    >


  export type TriageRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    resultJson?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["triageRun"]>

  export type TriageRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    resultJson?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["triageRun"]>

  export type TriageRunSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    resultJson?: boolean
  }

  export type TriageRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TriageRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TriageRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TriageRun"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      resultJson: string
    }, ExtArgs["result"]["triageRun"]>
    composites: {}
  }

  type TriageRunGetPayload<S extends boolean | null | undefined | TriageRunDefaultArgs> = $Result.GetResult<Prisma.$TriageRunPayload, S>

  type TriageRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TriageRunFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TriageRunCountAggregateInputType | true
    }

  export interface TriageRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TriageRun'], meta: { name: 'TriageRun' } }
    /**
     * Find zero or one TriageRun that matches the filter.
     * @param {TriageRunFindUniqueArgs} args - Arguments to find a TriageRun
     * @example
     * // Get one TriageRun
     * const triageRun = await prisma.triageRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TriageRunFindUniqueArgs>(args: SelectSubset<T, TriageRunFindUniqueArgs<ExtArgs>>): Prisma__TriageRunClient<$Result.GetResult<Prisma.$TriageRunPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TriageRun that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TriageRunFindUniqueOrThrowArgs} args - Arguments to find a TriageRun
     * @example
     * // Get one TriageRun
     * const triageRun = await prisma.triageRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TriageRunFindUniqueOrThrowArgs>(args: SelectSubset<T, TriageRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TriageRunClient<$Result.GetResult<Prisma.$TriageRunPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TriageRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriageRunFindFirstArgs} args - Arguments to find a TriageRun
     * @example
     * // Get one TriageRun
     * const triageRun = await prisma.triageRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TriageRunFindFirstArgs>(args?: SelectSubset<T, TriageRunFindFirstArgs<ExtArgs>>): Prisma__TriageRunClient<$Result.GetResult<Prisma.$TriageRunPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TriageRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriageRunFindFirstOrThrowArgs} args - Arguments to find a TriageRun
     * @example
     * // Get one TriageRun
     * const triageRun = await prisma.triageRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TriageRunFindFirstOrThrowArgs>(args?: SelectSubset<T, TriageRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__TriageRunClient<$Result.GetResult<Prisma.$TriageRunPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TriageRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriageRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TriageRuns
     * const triageRuns = await prisma.triageRun.findMany()
     * 
     * // Get first 10 TriageRuns
     * const triageRuns = await prisma.triageRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triageRunWithIdOnly = await prisma.triageRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TriageRunFindManyArgs>(args?: SelectSubset<T, TriageRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriageRunPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TriageRun.
     * @param {TriageRunCreateArgs} args - Arguments to create a TriageRun.
     * @example
     * // Create one TriageRun
     * const TriageRun = await prisma.triageRun.create({
     *   data: {
     *     // ... data to create a TriageRun
     *   }
     * })
     * 
     */
    create<T extends TriageRunCreateArgs>(args: SelectSubset<T, TriageRunCreateArgs<ExtArgs>>): Prisma__TriageRunClient<$Result.GetResult<Prisma.$TriageRunPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TriageRuns.
     * @param {TriageRunCreateManyArgs} args - Arguments to create many TriageRuns.
     * @example
     * // Create many TriageRuns
     * const triageRun = await prisma.triageRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TriageRunCreateManyArgs>(args?: SelectSubset<T, TriageRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TriageRuns and returns the data saved in the database.
     * @param {TriageRunCreateManyAndReturnArgs} args - Arguments to create many TriageRuns.
     * @example
     * // Create many TriageRuns
     * const triageRun = await prisma.triageRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TriageRuns and only return the `id`
     * const triageRunWithIdOnly = await prisma.triageRun.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TriageRunCreateManyAndReturnArgs>(args?: SelectSubset<T, TriageRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriageRunPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TriageRun.
     * @param {TriageRunDeleteArgs} args - Arguments to delete one TriageRun.
     * @example
     * // Delete one TriageRun
     * const TriageRun = await prisma.triageRun.delete({
     *   where: {
     *     // ... filter to delete one TriageRun
     *   }
     * })
     * 
     */
    delete<T extends TriageRunDeleteArgs>(args: SelectSubset<T, TriageRunDeleteArgs<ExtArgs>>): Prisma__TriageRunClient<$Result.GetResult<Prisma.$TriageRunPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TriageRun.
     * @param {TriageRunUpdateArgs} args - Arguments to update one TriageRun.
     * @example
     * // Update one TriageRun
     * const triageRun = await prisma.triageRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TriageRunUpdateArgs>(args: SelectSubset<T, TriageRunUpdateArgs<ExtArgs>>): Prisma__TriageRunClient<$Result.GetResult<Prisma.$TriageRunPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TriageRuns.
     * @param {TriageRunDeleteManyArgs} args - Arguments to filter TriageRuns to delete.
     * @example
     * // Delete a few TriageRuns
     * const { count } = await prisma.triageRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TriageRunDeleteManyArgs>(args?: SelectSubset<T, TriageRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TriageRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriageRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TriageRuns
     * const triageRun = await prisma.triageRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TriageRunUpdateManyArgs>(args: SelectSubset<T, TriageRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TriageRun.
     * @param {TriageRunUpsertArgs} args - Arguments to update or create a TriageRun.
     * @example
     * // Update or create a TriageRun
     * const triageRun = await prisma.triageRun.upsert({
     *   create: {
     *     // ... data to create a TriageRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TriageRun we want to update
     *   }
     * })
     */
    upsert<T extends TriageRunUpsertArgs>(args: SelectSubset<T, TriageRunUpsertArgs<ExtArgs>>): Prisma__TriageRunClient<$Result.GetResult<Prisma.$TriageRunPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TriageRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriageRunCountArgs} args - Arguments to filter TriageRuns to count.
     * @example
     * // Count the number of TriageRuns
     * const count = await prisma.triageRun.count({
     *   where: {
     *     // ... the filter for the TriageRuns we want to count
     *   }
     * })
    **/
    count<T extends TriageRunCountArgs>(
      args?: Subset<T, TriageRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriageRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TriageRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriageRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriageRunAggregateArgs>(args: Subset<T, TriageRunAggregateArgs>): Prisma.PrismaPromise<GetTriageRunAggregateType<T>>

    /**
     * Group by TriageRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriageRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriageRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriageRunGroupByArgs['orderBy'] }
        : { orderBy?: TriageRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriageRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriageRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TriageRun model
   */
  readonly fields: TriageRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TriageRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TriageRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TriageRun model
   */ 
  interface TriageRunFieldRefs {
    readonly id: FieldRef<"TriageRun", 'String'>
    readonly userId: FieldRef<"TriageRun", 'String'>
    readonly createdAt: FieldRef<"TriageRun", 'DateTime'>
    readonly resultJson: FieldRef<"TriageRun", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TriageRun findUnique
   */
  export type TriageRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriageRun
     */
    select?: TriageRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriageRunInclude<ExtArgs> | null
    /**
     * Filter, which TriageRun to fetch.
     */
    where: TriageRunWhereUniqueInput
  }

  /**
   * TriageRun findUniqueOrThrow
   */
  export type TriageRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriageRun
     */
    select?: TriageRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriageRunInclude<ExtArgs> | null
    /**
     * Filter, which TriageRun to fetch.
     */
    where: TriageRunWhereUniqueInput
  }

  /**
   * TriageRun findFirst
   */
  export type TriageRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriageRun
     */
    select?: TriageRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriageRunInclude<ExtArgs> | null
    /**
     * Filter, which TriageRun to fetch.
     */
    where?: TriageRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriageRuns to fetch.
     */
    orderBy?: TriageRunOrderByWithRelationInput | TriageRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriageRuns.
     */
    cursor?: TriageRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriageRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriageRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriageRuns.
     */
    distinct?: TriageRunScalarFieldEnum | TriageRunScalarFieldEnum[]
  }

  /**
   * TriageRun findFirstOrThrow
   */
  export type TriageRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriageRun
     */
    select?: TriageRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriageRunInclude<ExtArgs> | null
    /**
     * Filter, which TriageRun to fetch.
     */
    where?: TriageRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriageRuns to fetch.
     */
    orderBy?: TriageRunOrderByWithRelationInput | TriageRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriageRuns.
     */
    cursor?: TriageRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriageRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriageRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriageRuns.
     */
    distinct?: TriageRunScalarFieldEnum | TriageRunScalarFieldEnum[]
  }

  /**
   * TriageRun findMany
   */
  export type TriageRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriageRun
     */
    select?: TriageRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriageRunInclude<ExtArgs> | null
    /**
     * Filter, which TriageRuns to fetch.
     */
    where?: TriageRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriageRuns to fetch.
     */
    orderBy?: TriageRunOrderByWithRelationInput | TriageRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TriageRuns.
     */
    cursor?: TriageRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriageRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriageRuns.
     */
    skip?: number
    distinct?: TriageRunScalarFieldEnum | TriageRunScalarFieldEnum[]
  }

  /**
   * TriageRun create
   */
  export type TriageRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriageRun
     */
    select?: TriageRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriageRunInclude<ExtArgs> | null
    /**
     * The data needed to create a TriageRun.
     */
    data: XOR<TriageRunCreateInput, TriageRunUncheckedCreateInput>
  }

  /**
   * TriageRun createMany
   */
  export type TriageRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TriageRuns.
     */
    data: TriageRunCreateManyInput | TriageRunCreateManyInput[]
  }

  /**
   * TriageRun createManyAndReturn
   */
  export type TriageRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriageRun
     */
    select?: TriageRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TriageRuns.
     */
    data: TriageRunCreateManyInput | TriageRunCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriageRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TriageRun update
   */
  export type TriageRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriageRun
     */
    select?: TriageRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriageRunInclude<ExtArgs> | null
    /**
     * The data needed to update a TriageRun.
     */
    data: XOR<TriageRunUpdateInput, TriageRunUncheckedUpdateInput>
    /**
     * Choose, which TriageRun to update.
     */
    where: TriageRunWhereUniqueInput
  }

  /**
   * TriageRun updateMany
   */
  export type TriageRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TriageRuns.
     */
    data: XOR<TriageRunUpdateManyMutationInput, TriageRunUncheckedUpdateManyInput>
    /**
     * Filter which TriageRuns to update
     */
    where?: TriageRunWhereInput
  }

  /**
   * TriageRun upsert
   */
  export type TriageRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriageRun
     */
    select?: TriageRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriageRunInclude<ExtArgs> | null
    /**
     * The filter to search for the TriageRun to update in case it exists.
     */
    where: TriageRunWhereUniqueInput
    /**
     * In case the TriageRun found by the `where` argument doesn't exist, create a new TriageRun with this data.
     */
    create: XOR<TriageRunCreateInput, TriageRunUncheckedCreateInput>
    /**
     * In case the TriageRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriageRunUpdateInput, TriageRunUncheckedUpdateInput>
  }

  /**
   * TriageRun delete
   */
  export type TriageRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriageRun
     */
    select?: TriageRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriageRunInclude<ExtArgs> | null
    /**
     * Filter which TriageRun to delete.
     */
    where: TriageRunWhereUniqueInput
  }

  /**
   * TriageRun deleteMany
   */
  export type TriageRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TriageRuns to delete
     */
    where?: TriageRunWhereInput
  }

  /**
   * TriageRun without action
   */
  export type TriageRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriageRun
     */
    select?: TriageRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriageRunInclude<ExtArgs> | null
  }


  /**
   * Model LearningMaterial
   */

  export type AggregateLearningMaterial = {
    _count: LearningMaterialCountAggregateOutputType | null
    _min: LearningMaterialMinAggregateOutputType | null
    _max: LearningMaterialMaxAggregateOutputType | null
  }

  export type LearningMaterialMinAggregateOutputType = {
    id: string | null
    userId: string | null
    filename: string | null
    fileType: string | null
    extractedText: string | null
    createdAt: Date | null
  }

  export type LearningMaterialMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    filename: string | null
    fileType: string | null
    extractedText: string | null
    createdAt: Date | null
  }

  export type LearningMaterialCountAggregateOutputType = {
    id: number
    userId: number
    filename: number
    fileType: number
    extractedText: number
    createdAt: number
    _all: number
  }


  export type LearningMaterialMinAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    fileType?: true
    extractedText?: true
    createdAt?: true
  }

  export type LearningMaterialMaxAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    fileType?: true
    extractedText?: true
    createdAt?: true
  }

  export type LearningMaterialCountAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    fileType?: true
    extractedText?: true
    createdAt?: true
    _all?: true
  }

  export type LearningMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningMaterial to aggregate.
     */
    where?: LearningMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningMaterials to fetch.
     */
    orderBy?: LearningMaterialOrderByWithRelationInput | LearningMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningMaterials
    **/
    _count?: true | LearningMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningMaterialMaxAggregateInputType
  }

  export type GetLearningMaterialAggregateType<T extends LearningMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningMaterial[P]>
      : GetScalarType<T[P], AggregateLearningMaterial[P]>
  }




  export type LearningMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningMaterialWhereInput
    orderBy?: LearningMaterialOrderByWithAggregationInput | LearningMaterialOrderByWithAggregationInput[]
    by: LearningMaterialScalarFieldEnum[] | LearningMaterialScalarFieldEnum
    having?: LearningMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningMaterialCountAggregateInputType | true
    _min?: LearningMaterialMinAggregateInputType
    _max?: LearningMaterialMaxAggregateInputType
  }

  export type LearningMaterialGroupByOutputType = {
    id: string
    userId: string
    filename: string
    fileType: string
    extractedText: string | null
    createdAt: Date
    _count: LearningMaterialCountAggregateOutputType | null
    _min: LearningMaterialMinAggregateOutputType | null
    _max: LearningMaterialMaxAggregateOutputType | null
  }

  type GetLearningMaterialGroupByPayload<T extends LearningMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], LearningMaterialGroupByOutputType[P]>
        }
      >
    >


  export type LearningMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    filename?: boolean
    fileType?: boolean
    extractedText?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    artifacts?: boolean | LearningMaterial$artifactsArgs<ExtArgs>
    _count?: boolean | LearningMaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningMaterial"]>

  export type LearningMaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    filename?: boolean
    fileType?: boolean
    extractedText?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningMaterial"]>

  export type LearningMaterialSelectScalar = {
    id?: boolean
    userId?: boolean
    filename?: boolean
    fileType?: boolean
    extractedText?: boolean
    createdAt?: boolean
  }

  export type LearningMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    artifacts?: boolean | LearningMaterial$artifactsArgs<ExtArgs>
    _count?: boolean | LearningMaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LearningMaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LearningMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningMaterial"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      artifacts: Prisma.$LearningArtifactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      filename: string
      fileType: string
      extractedText: string | null
      createdAt: Date
    }, ExtArgs["result"]["learningMaterial"]>
    composites: {}
  }

  type LearningMaterialGetPayload<S extends boolean | null | undefined | LearningMaterialDefaultArgs> = $Result.GetResult<Prisma.$LearningMaterialPayload, S>

  type LearningMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearningMaterialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LearningMaterialCountAggregateInputType | true
    }

  export interface LearningMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningMaterial'], meta: { name: 'LearningMaterial' } }
    /**
     * Find zero or one LearningMaterial that matches the filter.
     * @param {LearningMaterialFindUniqueArgs} args - Arguments to find a LearningMaterial
     * @example
     * // Get one LearningMaterial
     * const learningMaterial = await prisma.learningMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningMaterialFindUniqueArgs>(args: SelectSubset<T, LearningMaterialFindUniqueArgs<ExtArgs>>): Prisma__LearningMaterialClient<$Result.GetResult<Prisma.$LearningMaterialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LearningMaterial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LearningMaterialFindUniqueOrThrowArgs} args - Arguments to find a LearningMaterial
     * @example
     * // Get one LearningMaterial
     * const learningMaterial = await prisma.learningMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningMaterialClient<$Result.GetResult<Prisma.$LearningMaterialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LearningMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningMaterialFindFirstArgs} args - Arguments to find a LearningMaterial
     * @example
     * // Get one LearningMaterial
     * const learningMaterial = await prisma.learningMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningMaterialFindFirstArgs>(args?: SelectSubset<T, LearningMaterialFindFirstArgs<ExtArgs>>): Prisma__LearningMaterialClient<$Result.GetResult<Prisma.$LearningMaterialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LearningMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningMaterialFindFirstOrThrowArgs} args - Arguments to find a LearningMaterial
     * @example
     * // Get one LearningMaterial
     * const learningMaterial = await prisma.learningMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningMaterialClient<$Result.GetResult<Prisma.$LearningMaterialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LearningMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningMaterials
     * const learningMaterials = await prisma.learningMaterial.findMany()
     * 
     * // Get first 10 LearningMaterials
     * const learningMaterials = await prisma.learningMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningMaterialWithIdOnly = await prisma.learningMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningMaterialFindManyArgs>(args?: SelectSubset<T, LearningMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningMaterialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LearningMaterial.
     * @param {LearningMaterialCreateArgs} args - Arguments to create a LearningMaterial.
     * @example
     * // Create one LearningMaterial
     * const LearningMaterial = await prisma.learningMaterial.create({
     *   data: {
     *     // ... data to create a LearningMaterial
     *   }
     * })
     * 
     */
    create<T extends LearningMaterialCreateArgs>(args: SelectSubset<T, LearningMaterialCreateArgs<ExtArgs>>): Prisma__LearningMaterialClient<$Result.GetResult<Prisma.$LearningMaterialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LearningMaterials.
     * @param {LearningMaterialCreateManyArgs} args - Arguments to create many LearningMaterials.
     * @example
     * // Create many LearningMaterials
     * const learningMaterial = await prisma.learningMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningMaterialCreateManyArgs>(args?: SelectSubset<T, LearningMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningMaterials and returns the data saved in the database.
     * @param {LearningMaterialCreateManyAndReturnArgs} args - Arguments to create many LearningMaterials.
     * @example
     * // Create many LearningMaterials
     * const learningMaterial = await prisma.learningMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningMaterials and only return the `id`
     * const learningMaterialWithIdOnly = await prisma.learningMaterial.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningMaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningMaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningMaterialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LearningMaterial.
     * @param {LearningMaterialDeleteArgs} args - Arguments to delete one LearningMaterial.
     * @example
     * // Delete one LearningMaterial
     * const LearningMaterial = await prisma.learningMaterial.delete({
     *   where: {
     *     // ... filter to delete one LearningMaterial
     *   }
     * })
     * 
     */
    delete<T extends LearningMaterialDeleteArgs>(args: SelectSubset<T, LearningMaterialDeleteArgs<ExtArgs>>): Prisma__LearningMaterialClient<$Result.GetResult<Prisma.$LearningMaterialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LearningMaterial.
     * @param {LearningMaterialUpdateArgs} args - Arguments to update one LearningMaterial.
     * @example
     * // Update one LearningMaterial
     * const learningMaterial = await prisma.learningMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningMaterialUpdateArgs>(args: SelectSubset<T, LearningMaterialUpdateArgs<ExtArgs>>): Prisma__LearningMaterialClient<$Result.GetResult<Prisma.$LearningMaterialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LearningMaterials.
     * @param {LearningMaterialDeleteManyArgs} args - Arguments to filter LearningMaterials to delete.
     * @example
     * // Delete a few LearningMaterials
     * const { count } = await prisma.learningMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningMaterialDeleteManyArgs>(args?: SelectSubset<T, LearningMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningMaterials
     * const learningMaterial = await prisma.learningMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningMaterialUpdateManyArgs>(args: SelectSubset<T, LearningMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearningMaterial.
     * @param {LearningMaterialUpsertArgs} args - Arguments to update or create a LearningMaterial.
     * @example
     * // Update or create a LearningMaterial
     * const learningMaterial = await prisma.learningMaterial.upsert({
     *   create: {
     *     // ... data to create a LearningMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningMaterial we want to update
     *   }
     * })
     */
    upsert<T extends LearningMaterialUpsertArgs>(args: SelectSubset<T, LearningMaterialUpsertArgs<ExtArgs>>): Prisma__LearningMaterialClient<$Result.GetResult<Prisma.$LearningMaterialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LearningMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningMaterialCountArgs} args - Arguments to filter LearningMaterials to count.
     * @example
     * // Count the number of LearningMaterials
     * const count = await prisma.learningMaterial.count({
     *   where: {
     *     // ... the filter for the LearningMaterials we want to count
     *   }
     * })
    **/
    count<T extends LearningMaterialCountArgs>(
      args?: Subset<T, LearningMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningMaterialAggregateArgs>(args: Subset<T, LearningMaterialAggregateArgs>): Prisma.PrismaPromise<GetLearningMaterialAggregateType<T>>

    /**
     * Group by LearningMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningMaterialGroupByArgs['orderBy'] }
        : { orderBy?: LearningMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningMaterial model
   */
  readonly fields: LearningMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    artifacts<T extends LearningMaterial$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, LearningMaterial$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningArtifactPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningMaterial model
   */ 
  interface LearningMaterialFieldRefs {
    readonly id: FieldRef<"LearningMaterial", 'String'>
    readonly userId: FieldRef<"LearningMaterial", 'String'>
    readonly filename: FieldRef<"LearningMaterial", 'String'>
    readonly fileType: FieldRef<"LearningMaterial", 'String'>
    readonly extractedText: FieldRef<"LearningMaterial", 'String'>
    readonly createdAt: FieldRef<"LearningMaterial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningMaterial findUnique
   */
  export type LearningMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterial
     */
    select?: LearningMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LearningMaterial to fetch.
     */
    where: LearningMaterialWhereUniqueInput
  }

  /**
   * LearningMaterial findUniqueOrThrow
   */
  export type LearningMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterial
     */
    select?: LearningMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LearningMaterial to fetch.
     */
    where: LearningMaterialWhereUniqueInput
  }

  /**
   * LearningMaterial findFirst
   */
  export type LearningMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterial
     */
    select?: LearningMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LearningMaterial to fetch.
     */
    where?: LearningMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningMaterials to fetch.
     */
    orderBy?: LearningMaterialOrderByWithRelationInput | LearningMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningMaterials.
     */
    cursor?: LearningMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningMaterials.
     */
    distinct?: LearningMaterialScalarFieldEnum | LearningMaterialScalarFieldEnum[]
  }

  /**
   * LearningMaterial findFirstOrThrow
   */
  export type LearningMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterial
     */
    select?: LearningMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LearningMaterial to fetch.
     */
    where?: LearningMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningMaterials to fetch.
     */
    orderBy?: LearningMaterialOrderByWithRelationInput | LearningMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningMaterials.
     */
    cursor?: LearningMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningMaterials.
     */
    distinct?: LearningMaterialScalarFieldEnum | LearningMaterialScalarFieldEnum[]
  }

  /**
   * LearningMaterial findMany
   */
  export type LearningMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterial
     */
    select?: LearningMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LearningMaterials to fetch.
     */
    where?: LearningMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningMaterials to fetch.
     */
    orderBy?: LearningMaterialOrderByWithRelationInput | LearningMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningMaterials.
     */
    cursor?: LearningMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningMaterials.
     */
    skip?: number
    distinct?: LearningMaterialScalarFieldEnum | LearningMaterialScalarFieldEnum[]
  }

  /**
   * LearningMaterial create
   */
  export type LearningMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterial
     */
    select?: LearningMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningMaterial.
     */
    data: XOR<LearningMaterialCreateInput, LearningMaterialUncheckedCreateInput>
  }

  /**
   * LearningMaterial createMany
   */
  export type LearningMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningMaterials.
     */
    data: LearningMaterialCreateManyInput | LearningMaterialCreateManyInput[]
  }

  /**
   * LearningMaterial createManyAndReturn
   */
  export type LearningMaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterial
     */
    select?: LearningMaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LearningMaterials.
     */
    data: LearningMaterialCreateManyInput | LearningMaterialCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningMaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningMaterial update
   */
  export type LearningMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterial
     */
    select?: LearningMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningMaterial.
     */
    data: XOR<LearningMaterialUpdateInput, LearningMaterialUncheckedUpdateInput>
    /**
     * Choose, which LearningMaterial to update.
     */
    where: LearningMaterialWhereUniqueInput
  }

  /**
   * LearningMaterial updateMany
   */
  export type LearningMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningMaterials.
     */
    data: XOR<LearningMaterialUpdateManyMutationInput, LearningMaterialUncheckedUpdateManyInput>
    /**
     * Filter which LearningMaterials to update
     */
    where?: LearningMaterialWhereInput
  }

  /**
   * LearningMaterial upsert
   */
  export type LearningMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterial
     */
    select?: LearningMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningMaterial to update in case it exists.
     */
    where: LearningMaterialWhereUniqueInput
    /**
     * In case the LearningMaterial found by the `where` argument doesn't exist, create a new LearningMaterial with this data.
     */
    create: XOR<LearningMaterialCreateInput, LearningMaterialUncheckedCreateInput>
    /**
     * In case the LearningMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningMaterialUpdateInput, LearningMaterialUncheckedUpdateInput>
  }

  /**
   * LearningMaterial delete
   */
  export type LearningMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterial
     */
    select?: LearningMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningMaterialInclude<ExtArgs> | null
    /**
     * Filter which LearningMaterial to delete.
     */
    where: LearningMaterialWhereUniqueInput
  }

  /**
   * LearningMaterial deleteMany
   */
  export type LearningMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningMaterials to delete
     */
    where?: LearningMaterialWhereInput
  }

  /**
   * LearningMaterial.artifacts
   */
  export type LearningMaterial$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningArtifact
     */
    select?: LearningArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningArtifactInclude<ExtArgs> | null
    where?: LearningArtifactWhereInput
    orderBy?: LearningArtifactOrderByWithRelationInput | LearningArtifactOrderByWithRelationInput[]
    cursor?: LearningArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningArtifactScalarFieldEnum | LearningArtifactScalarFieldEnum[]
  }

  /**
   * LearningMaterial without action
   */
  export type LearningMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningMaterial
     */
    select?: LearningMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningMaterialInclude<ExtArgs> | null
  }


  /**
   * Model LearningArtifact
   */

  export type AggregateLearningArtifact = {
    _count: LearningArtifactCountAggregateOutputType | null
    _min: LearningArtifactMinAggregateOutputType | null
    _max: LearningArtifactMaxAggregateOutputType | null
  }

  export type LearningArtifactMinAggregateOutputType = {
    id: string | null
    learningMaterialId: string | null
    type: string | null
    artifactJson: string | null
    createdAt: Date | null
  }

  export type LearningArtifactMaxAggregateOutputType = {
    id: string | null
    learningMaterialId: string | null
    type: string | null
    artifactJson: string | null
    createdAt: Date | null
  }

  export type LearningArtifactCountAggregateOutputType = {
    id: number
    learningMaterialId: number
    type: number
    artifactJson: number
    createdAt: number
    _all: number
  }


  export type LearningArtifactMinAggregateInputType = {
    id?: true
    learningMaterialId?: true
    type?: true
    artifactJson?: true
    createdAt?: true
  }

  export type LearningArtifactMaxAggregateInputType = {
    id?: true
    learningMaterialId?: true
    type?: true
    artifactJson?: true
    createdAt?: true
  }

  export type LearningArtifactCountAggregateInputType = {
    id?: true
    learningMaterialId?: true
    type?: true
    artifactJson?: true
    createdAt?: true
    _all?: true
  }

  export type LearningArtifactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningArtifact to aggregate.
     */
    where?: LearningArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningArtifacts to fetch.
     */
    orderBy?: LearningArtifactOrderByWithRelationInput | LearningArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningArtifacts
    **/
    _count?: true | LearningArtifactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningArtifactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningArtifactMaxAggregateInputType
  }

  export type GetLearningArtifactAggregateType<T extends LearningArtifactAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningArtifact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningArtifact[P]>
      : GetScalarType<T[P], AggregateLearningArtifact[P]>
  }




  export type LearningArtifactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningArtifactWhereInput
    orderBy?: LearningArtifactOrderByWithAggregationInput | LearningArtifactOrderByWithAggregationInput[]
    by: LearningArtifactScalarFieldEnum[] | LearningArtifactScalarFieldEnum
    having?: LearningArtifactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningArtifactCountAggregateInputType | true
    _min?: LearningArtifactMinAggregateInputType
    _max?: LearningArtifactMaxAggregateInputType
  }

  export type LearningArtifactGroupByOutputType = {
    id: string
    learningMaterialId: string
    type: string
    artifactJson: string
    createdAt: Date
    _count: LearningArtifactCountAggregateOutputType | null
    _min: LearningArtifactMinAggregateOutputType | null
    _max: LearningArtifactMaxAggregateOutputType | null
  }

  type GetLearningArtifactGroupByPayload<T extends LearningArtifactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningArtifactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningArtifactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningArtifactGroupByOutputType[P]>
            : GetScalarType<T[P], LearningArtifactGroupByOutputType[P]>
        }
      >
    >


  export type LearningArtifactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    learningMaterialId?: boolean
    type?: boolean
    artifactJson?: boolean
    createdAt?: boolean
    learningMaterial?: boolean | LearningMaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningArtifact"]>

  export type LearningArtifactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    learningMaterialId?: boolean
    type?: boolean
    artifactJson?: boolean
    createdAt?: boolean
    learningMaterial?: boolean | LearningMaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningArtifact"]>

  export type LearningArtifactSelectScalar = {
    id?: boolean
    learningMaterialId?: boolean
    type?: boolean
    artifactJson?: boolean
    createdAt?: boolean
  }

  export type LearningArtifactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningMaterial?: boolean | LearningMaterialDefaultArgs<ExtArgs>
  }
  export type LearningArtifactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningMaterial?: boolean | LearningMaterialDefaultArgs<ExtArgs>
  }

  export type $LearningArtifactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningArtifact"
    objects: {
      learningMaterial: Prisma.$LearningMaterialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      learningMaterialId: string
      type: string
      artifactJson: string
      createdAt: Date
    }, ExtArgs["result"]["learningArtifact"]>
    composites: {}
  }

  type LearningArtifactGetPayload<S extends boolean | null | undefined | LearningArtifactDefaultArgs> = $Result.GetResult<Prisma.$LearningArtifactPayload, S>

  type LearningArtifactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearningArtifactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LearningArtifactCountAggregateInputType | true
    }

  export interface LearningArtifactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningArtifact'], meta: { name: 'LearningArtifact' } }
    /**
     * Find zero or one LearningArtifact that matches the filter.
     * @param {LearningArtifactFindUniqueArgs} args - Arguments to find a LearningArtifact
     * @example
     * // Get one LearningArtifact
     * const learningArtifact = await prisma.learningArtifact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningArtifactFindUniqueArgs>(args: SelectSubset<T, LearningArtifactFindUniqueArgs<ExtArgs>>): Prisma__LearningArtifactClient<$Result.GetResult<Prisma.$LearningArtifactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LearningArtifact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LearningArtifactFindUniqueOrThrowArgs} args - Arguments to find a LearningArtifact
     * @example
     * // Get one LearningArtifact
     * const learningArtifact = await prisma.learningArtifact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningArtifactFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningArtifactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningArtifactClient<$Result.GetResult<Prisma.$LearningArtifactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LearningArtifact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningArtifactFindFirstArgs} args - Arguments to find a LearningArtifact
     * @example
     * // Get one LearningArtifact
     * const learningArtifact = await prisma.learningArtifact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningArtifactFindFirstArgs>(args?: SelectSubset<T, LearningArtifactFindFirstArgs<ExtArgs>>): Prisma__LearningArtifactClient<$Result.GetResult<Prisma.$LearningArtifactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LearningArtifact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningArtifactFindFirstOrThrowArgs} args - Arguments to find a LearningArtifact
     * @example
     * // Get one LearningArtifact
     * const learningArtifact = await prisma.learningArtifact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningArtifactFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningArtifactFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningArtifactClient<$Result.GetResult<Prisma.$LearningArtifactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LearningArtifacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningArtifactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningArtifacts
     * const learningArtifacts = await prisma.learningArtifact.findMany()
     * 
     * // Get first 10 LearningArtifacts
     * const learningArtifacts = await prisma.learningArtifact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningArtifactWithIdOnly = await prisma.learningArtifact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningArtifactFindManyArgs>(args?: SelectSubset<T, LearningArtifactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningArtifactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LearningArtifact.
     * @param {LearningArtifactCreateArgs} args - Arguments to create a LearningArtifact.
     * @example
     * // Create one LearningArtifact
     * const LearningArtifact = await prisma.learningArtifact.create({
     *   data: {
     *     // ... data to create a LearningArtifact
     *   }
     * })
     * 
     */
    create<T extends LearningArtifactCreateArgs>(args: SelectSubset<T, LearningArtifactCreateArgs<ExtArgs>>): Prisma__LearningArtifactClient<$Result.GetResult<Prisma.$LearningArtifactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LearningArtifacts.
     * @param {LearningArtifactCreateManyArgs} args - Arguments to create many LearningArtifacts.
     * @example
     * // Create many LearningArtifacts
     * const learningArtifact = await prisma.learningArtifact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningArtifactCreateManyArgs>(args?: SelectSubset<T, LearningArtifactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningArtifacts and returns the data saved in the database.
     * @param {LearningArtifactCreateManyAndReturnArgs} args - Arguments to create many LearningArtifacts.
     * @example
     * // Create many LearningArtifacts
     * const learningArtifact = await prisma.learningArtifact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningArtifacts and only return the `id`
     * const learningArtifactWithIdOnly = await prisma.learningArtifact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningArtifactCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningArtifactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningArtifactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LearningArtifact.
     * @param {LearningArtifactDeleteArgs} args - Arguments to delete one LearningArtifact.
     * @example
     * // Delete one LearningArtifact
     * const LearningArtifact = await prisma.learningArtifact.delete({
     *   where: {
     *     // ... filter to delete one LearningArtifact
     *   }
     * })
     * 
     */
    delete<T extends LearningArtifactDeleteArgs>(args: SelectSubset<T, LearningArtifactDeleteArgs<ExtArgs>>): Prisma__LearningArtifactClient<$Result.GetResult<Prisma.$LearningArtifactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LearningArtifact.
     * @param {LearningArtifactUpdateArgs} args - Arguments to update one LearningArtifact.
     * @example
     * // Update one LearningArtifact
     * const learningArtifact = await prisma.learningArtifact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningArtifactUpdateArgs>(args: SelectSubset<T, LearningArtifactUpdateArgs<ExtArgs>>): Prisma__LearningArtifactClient<$Result.GetResult<Prisma.$LearningArtifactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LearningArtifacts.
     * @param {LearningArtifactDeleteManyArgs} args - Arguments to filter LearningArtifacts to delete.
     * @example
     * // Delete a few LearningArtifacts
     * const { count } = await prisma.learningArtifact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningArtifactDeleteManyArgs>(args?: SelectSubset<T, LearningArtifactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningArtifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningArtifactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningArtifacts
     * const learningArtifact = await prisma.learningArtifact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningArtifactUpdateManyArgs>(args: SelectSubset<T, LearningArtifactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearningArtifact.
     * @param {LearningArtifactUpsertArgs} args - Arguments to update or create a LearningArtifact.
     * @example
     * // Update or create a LearningArtifact
     * const learningArtifact = await prisma.learningArtifact.upsert({
     *   create: {
     *     // ... data to create a LearningArtifact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningArtifact we want to update
     *   }
     * })
     */
    upsert<T extends LearningArtifactUpsertArgs>(args: SelectSubset<T, LearningArtifactUpsertArgs<ExtArgs>>): Prisma__LearningArtifactClient<$Result.GetResult<Prisma.$LearningArtifactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LearningArtifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningArtifactCountArgs} args - Arguments to filter LearningArtifacts to count.
     * @example
     * // Count the number of LearningArtifacts
     * const count = await prisma.learningArtifact.count({
     *   where: {
     *     // ... the filter for the LearningArtifacts we want to count
     *   }
     * })
    **/
    count<T extends LearningArtifactCountArgs>(
      args?: Subset<T, LearningArtifactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningArtifactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningArtifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningArtifactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningArtifactAggregateArgs>(args: Subset<T, LearningArtifactAggregateArgs>): Prisma.PrismaPromise<GetLearningArtifactAggregateType<T>>

    /**
     * Group by LearningArtifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningArtifactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningArtifactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningArtifactGroupByArgs['orderBy'] }
        : { orderBy?: LearningArtifactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningArtifactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningArtifactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningArtifact model
   */
  readonly fields: LearningArtifactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningArtifact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningArtifactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learningMaterial<T extends LearningMaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningMaterialDefaultArgs<ExtArgs>>): Prisma__LearningMaterialClient<$Result.GetResult<Prisma.$LearningMaterialPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningArtifact model
   */ 
  interface LearningArtifactFieldRefs {
    readonly id: FieldRef<"LearningArtifact", 'String'>
    readonly learningMaterialId: FieldRef<"LearningArtifact", 'String'>
    readonly type: FieldRef<"LearningArtifact", 'String'>
    readonly artifactJson: FieldRef<"LearningArtifact", 'String'>
    readonly createdAt: FieldRef<"LearningArtifact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningArtifact findUnique
   */
  export type LearningArtifactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningArtifact
     */
    select?: LearningArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningArtifactInclude<ExtArgs> | null
    /**
     * Filter, which LearningArtifact to fetch.
     */
    where: LearningArtifactWhereUniqueInput
  }

  /**
   * LearningArtifact findUniqueOrThrow
   */
  export type LearningArtifactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningArtifact
     */
    select?: LearningArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningArtifactInclude<ExtArgs> | null
    /**
     * Filter, which LearningArtifact to fetch.
     */
    where: LearningArtifactWhereUniqueInput
  }

  /**
   * LearningArtifact findFirst
   */
  export type LearningArtifactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningArtifact
     */
    select?: LearningArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningArtifactInclude<ExtArgs> | null
    /**
     * Filter, which LearningArtifact to fetch.
     */
    where?: LearningArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningArtifacts to fetch.
     */
    orderBy?: LearningArtifactOrderByWithRelationInput | LearningArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningArtifacts.
     */
    cursor?: LearningArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningArtifacts.
     */
    distinct?: LearningArtifactScalarFieldEnum | LearningArtifactScalarFieldEnum[]
  }

  /**
   * LearningArtifact findFirstOrThrow
   */
  export type LearningArtifactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningArtifact
     */
    select?: LearningArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningArtifactInclude<ExtArgs> | null
    /**
     * Filter, which LearningArtifact to fetch.
     */
    where?: LearningArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningArtifacts to fetch.
     */
    orderBy?: LearningArtifactOrderByWithRelationInput | LearningArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningArtifacts.
     */
    cursor?: LearningArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningArtifacts.
     */
    distinct?: LearningArtifactScalarFieldEnum | LearningArtifactScalarFieldEnum[]
  }

  /**
   * LearningArtifact findMany
   */
  export type LearningArtifactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningArtifact
     */
    select?: LearningArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningArtifactInclude<ExtArgs> | null
    /**
     * Filter, which LearningArtifacts to fetch.
     */
    where?: LearningArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningArtifacts to fetch.
     */
    orderBy?: LearningArtifactOrderByWithRelationInput | LearningArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningArtifacts.
     */
    cursor?: LearningArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningArtifacts.
     */
    skip?: number
    distinct?: LearningArtifactScalarFieldEnum | LearningArtifactScalarFieldEnum[]
  }

  /**
   * LearningArtifact create
   */
  export type LearningArtifactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningArtifact
     */
    select?: LearningArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningArtifactInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningArtifact.
     */
    data: XOR<LearningArtifactCreateInput, LearningArtifactUncheckedCreateInput>
  }

  /**
   * LearningArtifact createMany
   */
  export type LearningArtifactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningArtifacts.
     */
    data: LearningArtifactCreateManyInput | LearningArtifactCreateManyInput[]
  }

  /**
   * LearningArtifact createManyAndReturn
   */
  export type LearningArtifactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningArtifact
     */
    select?: LearningArtifactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LearningArtifacts.
     */
    data: LearningArtifactCreateManyInput | LearningArtifactCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningArtifactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningArtifact update
   */
  export type LearningArtifactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningArtifact
     */
    select?: LearningArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningArtifactInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningArtifact.
     */
    data: XOR<LearningArtifactUpdateInput, LearningArtifactUncheckedUpdateInput>
    /**
     * Choose, which LearningArtifact to update.
     */
    where: LearningArtifactWhereUniqueInput
  }

  /**
   * LearningArtifact updateMany
   */
  export type LearningArtifactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningArtifacts.
     */
    data: XOR<LearningArtifactUpdateManyMutationInput, LearningArtifactUncheckedUpdateManyInput>
    /**
     * Filter which LearningArtifacts to update
     */
    where?: LearningArtifactWhereInput
  }

  /**
   * LearningArtifact upsert
   */
  export type LearningArtifactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningArtifact
     */
    select?: LearningArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningArtifactInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningArtifact to update in case it exists.
     */
    where: LearningArtifactWhereUniqueInput
    /**
     * In case the LearningArtifact found by the `where` argument doesn't exist, create a new LearningArtifact with this data.
     */
    create: XOR<LearningArtifactCreateInput, LearningArtifactUncheckedCreateInput>
    /**
     * In case the LearningArtifact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningArtifactUpdateInput, LearningArtifactUncheckedUpdateInput>
  }

  /**
   * LearningArtifact delete
   */
  export type LearningArtifactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningArtifact
     */
    select?: LearningArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningArtifactInclude<ExtArgs> | null
    /**
     * Filter which LearningArtifact to delete.
     */
    where: LearningArtifactWhereUniqueInput
  }

  /**
   * LearningArtifact deleteMany
   */
  export type LearningArtifactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningArtifacts to delete
     */
    where?: LearningArtifactWhereInput
  }

  /**
   * LearningArtifact without action
   */
  export type LearningArtifactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningArtifact
     */
    select?: LearningArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningArtifactInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GoogleAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    googleSub: 'googleSub',
    accessTokenEnc: 'accessTokenEnc',
    refreshTokenEnc: 'refreshTokenEnc',
    expiryDate: 'expiryDate',
    scopes: 'scopes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GoogleAccountScalarFieldEnum = (typeof GoogleAccountScalarFieldEnum)[keyof typeof GoogleAccountScalarFieldEnum]


  export const EmailItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gmailId: 'gmailId',
    threadId: 'threadId',
    from: 'from',
    subject: 'subject',
    snippet: 'snippet',
    receivedAt: 'receivedAt',
    isUnread: 'isUnread',
    rawJson: 'rawJson'
  };

  export type EmailItemScalarFieldEnum = (typeof EmailItemScalarFieldEnum)[keyof typeof EmailItemScalarFieldEnum]


  export const CalendarEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gcalId: 'gcalId',
    title: 'title',
    start: 'start',
    end: 'end',
    location: 'location',
    rawJson: 'rawJson'
  };

  export type CalendarEventScalarFieldEnum = (typeof CalendarEventScalarFieldEnum)[keyof typeof CalendarEventScalarFieldEnum]


  export const DocItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fileId: 'fileId',
    title: 'title',
    sourceType: 'sourceType',
    modifiedTime: 'modifiedTime',
    extractedText: 'extractedText',
    textHash: 'textHash',
    rawJson: 'rawJson'
  };

  export type DocItemScalarFieldEnum = (typeof DocItemScalarFieldEnum)[keyof typeof DocItemScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    dueAt: 'dueAt',
    estMins: 'estMins',
    priority: 'priority',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    weekStartDate: 'weekStartDate',
    planJson: 'planJson',
    createdAt: 'createdAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const TriageRunScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    resultJson: 'resultJson'
  };

  export type TriageRunScalarFieldEnum = (typeof TriageRunScalarFieldEnum)[keyof typeof TriageRunScalarFieldEnum]


  export const LearningMaterialScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    filename: 'filename',
    fileType: 'fileType',
    extractedText: 'extractedText',
    createdAt: 'createdAt'
  };

  export type LearningMaterialScalarFieldEnum = (typeof LearningMaterialScalarFieldEnum)[keyof typeof LearningMaterialScalarFieldEnum]


  export const LearningArtifactScalarFieldEnum: {
    id: 'id',
    learningMaterialId: 'learningMaterialId',
    type: 'type',
    artifactJson: 'artifactJson',
    createdAt: 'createdAt'
  };

  export type LearningArtifactScalarFieldEnum = (typeof LearningArtifactScalarFieldEnum)[keyof typeof LearningArtifactScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    googleAccount?: XOR<GoogleAccountNullableRelationFilter, GoogleAccountWhereInput> | null
    emailItems?: EmailItemListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
    docItems?: DocItemListRelationFilter
    tasks?: TaskListRelationFilter
    plans?: PlanListRelationFilter
    triageRuns?: TriageRunListRelationFilter
    learningMaterials?: LearningMaterialListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    googleAccount?: GoogleAccountOrderByWithRelationInput
    emailItems?: EmailItemOrderByRelationAggregateInput
    calendarEvents?: CalendarEventOrderByRelationAggregateInput
    docItems?: DocItemOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    plans?: PlanOrderByRelationAggregateInput
    triageRuns?: TriageRunOrderByRelationAggregateInput
    learningMaterials?: LearningMaterialOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    googleAccount?: XOR<GoogleAccountNullableRelationFilter, GoogleAccountWhereInput> | null
    emailItems?: EmailItemListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
    docItems?: DocItemListRelationFilter
    tasks?: TaskListRelationFilter
    plans?: PlanListRelationFilter
    triageRuns?: TriageRunListRelationFilter
    learningMaterials?: LearningMaterialListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type GoogleAccountWhereInput = {
    AND?: GoogleAccountWhereInput | GoogleAccountWhereInput[]
    OR?: GoogleAccountWhereInput[]
    NOT?: GoogleAccountWhereInput | GoogleAccountWhereInput[]
    id?: StringFilter<"GoogleAccount"> | string
    userId?: StringFilter<"GoogleAccount"> | string
    googleSub?: StringFilter<"GoogleAccount"> | string
    accessTokenEnc?: StringFilter<"GoogleAccount"> | string
    refreshTokenEnc?: StringFilter<"GoogleAccount"> | string
    expiryDate?: BigIntNullableFilter<"GoogleAccount"> | bigint | number | null
    scopes?: StringFilter<"GoogleAccount"> | string
    createdAt?: DateTimeFilter<"GoogleAccount"> | Date | string
    updatedAt?: DateTimeFilter<"GoogleAccount"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GoogleAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    googleSub?: SortOrder
    accessTokenEnc?: SortOrder
    refreshTokenEnc?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    scopes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GoogleAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: GoogleAccountWhereInput | GoogleAccountWhereInput[]
    OR?: GoogleAccountWhereInput[]
    NOT?: GoogleAccountWhereInput | GoogleAccountWhereInput[]
    googleSub?: StringFilter<"GoogleAccount"> | string
    accessTokenEnc?: StringFilter<"GoogleAccount"> | string
    refreshTokenEnc?: StringFilter<"GoogleAccount"> | string
    expiryDate?: BigIntNullableFilter<"GoogleAccount"> | bigint | number | null
    scopes?: StringFilter<"GoogleAccount"> | string
    createdAt?: DateTimeFilter<"GoogleAccount"> | Date | string
    updatedAt?: DateTimeFilter<"GoogleAccount"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type GoogleAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    googleSub?: SortOrder
    accessTokenEnc?: SortOrder
    refreshTokenEnc?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    scopes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GoogleAccountCountOrderByAggregateInput
    _avg?: GoogleAccountAvgOrderByAggregateInput
    _max?: GoogleAccountMaxOrderByAggregateInput
    _min?: GoogleAccountMinOrderByAggregateInput
    _sum?: GoogleAccountSumOrderByAggregateInput
  }

  export type GoogleAccountScalarWhereWithAggregatesInput = {
    AND?: GoogleAccountScalarWhereWithAggregatesInput | GoogleAccountScalarWhereWithAggregatesInput[]
    OR?: GoogleAccountScalarWhereWithAggregatesInput[]
    NOT?: GoogleAccountScalarWhereWithAggregatesInput | GoogleAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GoogleAccount"> | string
    userId?: StringWithAggregatesFilter<"GoogleAccount"> | string
    googleSub?: StringWithAggregatesFilter<"GoogleAccount"> | string
    accessTokenEnc?: StringWithAggregatesFilter<"GoogleAccount"> | string
    refreshTokenEnc?: StringWithAggregatesFilter<"GoogleAccount"> | string
    expiryDate?: BigIntNullableWithAggregatesFilter<"GoogleAccount"> | bigint | number | null
    scopes?: StringWithAggregatesFilter<"GoogleAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GoogleAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GoogleAccount"> | Date | string
  }

  export type EmailItemWhereInput = {
    AND?: EmailItemWhereInput | EmailItemWhereInput[]
    OR?: EmailItemWhereInput[]
    NOT?: EmailItemWhereInput | EmailItemWhereInput[]
    id?: StringFilter<"EmailItem"> | string
    userId?: StringFilter<"EmailItem"> | string
    gmailId?: StringFilter<"EmailItem"> | string
    threadId?: StringNullableFilter<"EmailItem"> | string | null
    from?: StringFilter<"EmailItem"> | string
    subject?: StringFilter<"EmailItem"> | string
    snippet?: StringFilter<"EmailItem"> | string
    receivedAt?: DateTimeFilter<"EmailItem"> | Date | string
    isUnread?: BoolFilter<"EmailItem"> | boolean
    rawJson?: StringFilter<"EmailItem"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EmailItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gmailId?: SortOrder
    threadId?: SortOrderInput | SortOrder
    from?: SortOrder
    subject?: SortOrder
    snippet?: SortOrder
    receivedAt?: SortOrder
    isUnread?: SortOrder
    rawJson?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gmailId?: string
    AND?: EmailItemWhereInput | EmailItemWhereInput[]
    OR?: EmailItemWhereInput[]
    NOT?: EmailItemWhereInput | EmailItemWhereInput[]
    userId?: StringFilter<"EmailItem"> | string
    threadId?: StringNullableFilter<"EmailItem"> | string | null
    from?: StringFilter<"EmailItem"> | string
    subject?: StringFilter<"EmailItem"> | string
    snippet?: StringFilter<"EmailItem"> | string
    receivedAt?: DateTimeFilter<"EmailItem"> | Date | string
    isUnread?: BoolFilter<"EmailItem"> | boolean
    rawJson?: StringFilter<"EmailItem"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "gmailId">

  export type EmailItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gmailId?: SortOrder
    threadId?: SortOrderInput | SortOrder
    from?: SortOrder
    subject?: SortOrder
    snippet?: SortOrder
    receivedAt?: SortOrder
    isUnread?: SortOrder
    rawJson?: SortOrder
    _count?: EmailItemCountOrderByAggregateInput
    _max?: EmailItemMaxOrderByAggregateInput
    _min?: EmailItemMinOrderByAggregateInput
  }

  export type EmailItemScalarWhereWithAggregatesInput = {
    AND?: EmailItemScalarWhereWithAggregatesInput | EmailItemScalarWhereWithAggregatesInput[]
    OR?: EmailItemScalarWhereWithAggregatesInput[]
    NOT?: EmailItemScalarWhereWithAggregatesInput | EmailItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailItem"> | string
    userId?: StringWithAggregatesFilter<"EmailItem"> | string
    gmailId?: StringWithAggregatesFilter<"EmailItem"> | string
    threadId?: StringNullableWithAggregatesFilter<"EmailItem"> | string | null
    from?: StringWithAggregatesFilter<"EmailItem"> | string
    subject?: StringWithAggregatesFilter<"EmailItem"> | string
    snippet?: StringWithAggregatesFilter<"EmailItem"> | string
    receivedAt?: DateTimeWithAggregatesFilter<"EmailItem"> | Date | string
    isUnread?: BoolWithAggregatesFilter<"EmailItem"> | boolean
    rawJson?: StringWithAggregatesFilter<"EmailItem"> | string
  }

  export type CalendarEventWhereInput = {
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    id?: StringFilter<"CalendarEvent"> | string
    userId?: StringFilter<"CalendarEvent"> | string
    gcalId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    start?: DateTimeFilter<"CalendarEvent"> | Date | string
    end?: DateTimeFilter<"CalendarEvent"> | Date | string
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    rawJson?: StringFilter<"CalendarEvent"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CalendarEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gcalId?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    location?: SortOrderInput | SortOrder
    rawJson?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CalendarEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gcalId?: string
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    userId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    start?: DateTimeFilter<"CalendarEvent"> | Date | string
    end?: DateTimeFilter<"CalendarEvent"> | Date | string
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    rawJson?: StringFilter<"CalendarEvent"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "gcalId">

  export type CalendarEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gcalId?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    location?: SortOrderInput | SortOrder
    rawJson?: SortOrder
    _count?: CalendarEventCountOrderByAggregateInput
    _max?: CalendarEventMaxOrderByAggregateInput
    _min?: CalendarEventMinOrderByAggregateInput
  }

  export type CalendarEventScalarWhereWithAggregatesInput = {
    AND?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    OR?: CalendarEventScalarWhereWithAggregatesInput[]
    NOT?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarEvent"> | string
    userId?: StringWithAggregatesFilter<"CalendarEvent"> | string
    gcalId?: StringWithAggregatesFilter<"CalendarEvent"> | string
    title?: StringWithAggregatesFilter<"CalendarEvent"> | string
    start?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    end?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    location?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    rawJson?: StringWithAggregatesFilter<"CalendarEvent"> | string
  }

  export type DocItemWhereInput = {
    AND?: DocItemWhereInput | DocItemWhereInput[]
    OR?: DocItemWhereInput[]
    NOT?: DocItemWhereInput | DocItemWhereInput[]
    id?: StringFilter<"DocItem"> | string
    userId?: StringFilter<"DocItem"> | string
    fileId?: StringFilter<"DocItem"> | string
    title?: StringFilter<"DocItem"> | string
    sourceType?: StringFilter<"DocItem"> | string
    modifiedTime?: DateTimeFilter<"DocItem"> | Date | string
    extractedText?: StringNullableFilter<"DocItem"> | string | null
    textHash?: StringNullableFilter<"DocItem"> | string | null
    rawJson?: StringFilter<"DocItem"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DocItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fileId?: SortOrder
    title?: SortOrder
    sourceType?: SortOrder
    modifiedTime?: SortOrder
    extractedText?: SortOrderInput | SortOrder
    textHash?: SortOrderInput | SortOrder
    rawJson?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DocItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fileId?: string
    AND?: DocItemWhereInput | DocItemWhereInput[]
    OR?: DocItemWhereInput[]
    NOT?: DocItemWhereInput | DocItemWhereInput[]
    userId?: StringFilter<"DocItem"> | string
    title?: StringFilter<"DocItem"> | string
    sourceType?: StringFilter<"DocItem"> | string
    modifiedTime?: DateTimeFilter<"DocItem"> | Date | string
    extractedText?: StringNullableFilter<"DocItem"> | string | null
    textHash?: StringNullableFilter<"DocItem"> | string | null
    rawJson?: StringFilter<"DocItem"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "fileId">

  export type DocItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fileId?: SortOrder
    title?: SortOrder
    sourceType?: SortOrder
    modifiedTime?: SortOrder
    extractedText?: SortOrderInput | SortOrder
    textHash?: SortOrderInput | SortOrder
    rawJson?: SortOrder
    _count?: DocItemCountOrderByAggregateInput
    _max?: DocItemMaxOrderByAggregateInput
    _min?: DocItemMinOrderByAggregateInput
  }

  export type DocItemScalarWhereWithAggregatesInput = {
    AND?: DocItemScalarWhereWithAggregatesInput | DocItemScalarWhereWithAggregatesInput[]
    OR?: DocItemScalarWhereWithAggregatesInput[]
    NOT?: DocItemScalarWhereWithAggregatesInput | DocItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocItem"> | string
    userId?: StringWithAggregatesFilter<"DocItem"> | string
    fileId?: StringWithAggregatesFilter<"DocItem"> | string
    title?: StringWithAggregatesFilter<"DocItem"> | string
    sourceType?: StringWithAggregatesFilter<"DocItem"> | string
    modifiedTime?: DateTimeWithAggregatesFilter<"DocItem"> | Date | string
    extractedText?: StringNullableWithAggregatesFilter<"DocItem"> | string | null
    textHash?: StringNullableWithAggregatesFilter<"DocItem"> | string | null
    rawJson?: StringWithAggregatesFilter<"DocItem"> | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    userId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    sourceType?: StringFilter<"Task"> | string
    sourceId?: StringNullableFilter<"Task"> | string | null
    dueAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    estMins?: IntNullableFilter<"Task"> | number | null
    priority?: StringFilter<"Task"> | string
    status?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    dueAt?: SortOrderInput | SortOrder
    estMins?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    userId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    sourceType?: StringFilter<"Task"> | string
    sourceId?: StringNullableFilter<"Task"> | string | null
    dueAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    estMins?: IntNullableFilter<"Task"> | number | null
    priority?: StringFilter<"Task"> | string
    status?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    dueAt?: SortOrderInput | SortOrder
    estMins?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    userId?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    sourceType?: StringWithAggregatesFilter<"Task"> | string
    sourceId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    dueAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    estMins?: IntNullableWithAggregatesFilter<"Task"> | number | null
    priority?: StringWithAggregatesFilter<"Task"> | string
    status?: StringWithAggregatesFilter<"Task"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    userId?: StringFilter<"Plan"> | string
    weekStartDate?: DateTimeFilter<"Plan"> | Date | string
    planJson?: StringFilter<"Plan"> | string
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    weekStartDate?: SortOrder
    planJson?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    userId?: StringFilter<"Plan"> | string
    weekStartDate?: DateTimeFilter<"Plan"> | Date | string
    planJson?: StringFilter<"Plan"> | string
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    weekStartDate?: SortOrder
    planJson?: SortOrder
    createdAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    userId?: StringWithAggregatesFilter<"Plan"> | string
    weekStartDate?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    planJson?: StringWithAggregatesFilter<"Plan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type TriageRunWhereInput = {
    AND?: TriageRunWhereInput | TriageRunWhereInput[]
    OR?: TriageRunWhereInput[]
    NOT?: TriageRunWhereInput | TriageRunWhereInput[]
    id?: StringFilter<"TriageRun"> | string
    userId?: StringFilter<"TriageRun"> | string
    createdAt?: DateTimeFilter<"TriageRun"> | Date | string
    resultJson?: StringFilter<"TriageRun"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TriageRunOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    resultJson?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TriageRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TriageRunWhereInput | TriageRunWhereInput[]
    OR?: TriageRunWhereInput[]
    NOT?: TriageRunWhereInput | TriageRunWhereInput[]
    userId?: StringFilter<"TriageRun"> | string
    createdAt?: DateTimeFilter<"TriageRun"> | Date | string
    resultJson?: StringFilter<"TriageRun"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TriageRunOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    resultJson?: SortOrder
    _count?: TriageRunCountOrderByAggregateInput
    _max?: TriageRunMaxOrderByAggregateInput
    _min?: TriageRunMinOrderByAggregateInput
  }

  export type TriageRunScalarWhereWithAggregatesInput = {
    AND?: TriageRunScalarWhereWithAggregatesInput | TriageRunScalarWhereWithAggregatesInput[]
    OR?: TriageRunScalarWhereWithAggregatesInput[]
    NOT?: TriageRunScalarWhereWithAggregatesInput | TriageRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TriageRun"> | string
    userId?: StringWithAggregatesFilter<"TriageRun"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TriageRun"> | Date | string
    resultJson?: StringWithAggregatesFilter<"TriageRun"> | string
  }

  export type LearningMaterialWhereInput = {
    AND?: LearningMaterialWhereInput | LearningMaterialWhereInput[]
    OR?: LearningMaterialWhereInput[]
    NOT?: LearningMaterialWhereInput | LearningMaterialWhereInput[]
    id?: StringFilter<"LearningMaterial"> | string
    userId?: StringFilter<"LearningMaterial"> | string
    filename?: StringFilter<"LearningMaterial"> | string
    fileType?: StringFilter<"LearningMaterial"> | string
    extractedText?: StringNullableFilter<"LearningMaterial"> | string | null
    createdAt?: DateTimeFilter<"LearningMaterial"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    artifacts?: LearningArtifactListRelationFilter
  }

  export type LearningMaterialOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    extractedText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    artifacts?: LearningArtifactOrderByRelationAggregateInput
  }

  export type LearningMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningMaterialWhereInput | LearningMaterialWhereInput[]
    OR?: LearningMaterialWhereInput[]
    NOT?: LearningMaterialWhereInput | LearningMaterialWhereInput[]
    userId?: StringFilter<"LearningMaterial"> | string
    filename?: StringFilter<"LearningMaterial"> | string
    fileType?: StringFilter<"LearningMaterial"> | string
    extractedText?: StringNullableFilter<"LearningMaterial"> | string | null
    createdAt?: DateTimeFilter<"LearningMaterial"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    artifacts?: LearningArtifactListRelationFilter
  }, "id">

  export type LearningMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    extractedText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LearningMaterialCountOrderByAggregateInput
    _max?: LearningMaterialMaxOrderByAggregateInput
    _min?: LearningMaterialMinOrderByAggregateInput
  }

  export type LearningMaterialScalarWhereWithAggregatesInput = {
    AND?: LearningMaterialScalarWhereWithAggregatesInput | LearningMaterialScalarWhereWithAggregatesInput[]
    OR?: LearningMaterialScalarWhereWithAggregatesInput[]
    NOT?: LearningMaterialScalarWhereWithAggregatesInput | LearningMaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningMaterial"> | string
    userId?: StringWithAggregatesFilter<"LearningMaterial"> | string
    filename?: StringWithAggregatesFilter<"LearningMaterial"> | string
    fileType?: StringWithAggregatesFilter<"LearningMaterial"> | string
    extractedText?: StringNullableWithAggregatesFilter<"LearningMaterial"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LearningMaterial"> | Date | string
  }

  export type LearningArtifactWhereInput = {
    AND?: LearningArtifactWhereInput | LearningArtifactWhereInput[]
    OR?: LearningArtifactWhereInput[]
    NOT?: LearningArtifactWhereInput | LearningArtifactWhereInput[]
    id?: StringFilter<"LearningArtifact"> | string
    learningMaterialId?: StringFilter<"LearningArtifact"> | string
    type?: StringFilter<"LearningArtifact"> | string
    artifactJson?: StringFilter<"LearningArtifact"> | string
    createdAt?: DateTimeFilter<"LearningArtifact"> | Date | string
    learningMaterial?: XOR<LearningMaterialRelationFilter, LearningMaterialWhereInput>
  }

  export type LearningArtifactOrderByWithRelationInput = {
    id?: SortOrder
    learningMaterialId?: SortOrder
    type?: SortOrder
    artifactJson?: SortOrder
    createdAt?: SortOrder
    learningMaterial?: LearningMaterialOrderByWithRelationInput
  }

  export type LearningArtifactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningArtifactWhereInput | LearningArtifactWhereInput[]
    OR?: LearningArtifactWhereInput[]
    NOT?: LearningArtifactWhereInput | LearningArtifactWhereInput[]
    learningMaterialId?: StringFilter<"LearningArtifact"> | string
    type?: StringFilter<"LearningArtifact"> | string
    artifactJson?: StringFilter<"LearningArtifact"> | string
    createdAt?: DateTimeFilter<"LearningArtifact"> | Date | string
    learningMaterial?: XOR<LearningMaterialRelationFilter, LearningMaterialWhereInput>
  }, "id">

  export type LearningArtifactOrderByWithAggregationInput = {
    id?: SortOrder
    learningMaterialId?: SortOrder
    type?: SortOrder
    artifactJson?: SortOrder
    createdAt?: SortOrder
    _count?: LearningArtifactCountOrderByAggregateInput
    _max?: LearningArtifactMaxOrderByAggregateInput
    _min?: LearningArtifactMinOrderByAggregateInput
  }

  export type LearningArtifactScalarWhereWithAggregatesInput = {
    AND?: LearningArtifactScalarWhereWithAggregatesInput | LearningArtifactScalarWhereWithAggregatesInput[]
    OR?: LearningArtifactScalarWhereWithAggregatesInput[]
    NOT?: LearningArtifactScalarWhereWithAggregatesInput | LearningArtifactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningArtifact"> | string
    learningMaterialId?: StringWithAggregatesFilter<"LearningArtifact"> | string
    type?: StringWithAggregatesFilter<"LearningArtifact"> | string
    artifactJson?: StringWithAggregatesFilter<"LearningArtifact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LearningArtifact"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountCreateNestedOneWithoutUserInput
    emailItems?: EmailItemCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    docItems?: DocItemCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountUncheckedCreateNestedOneWithoutUserInput
    emailItems?: EmailItemUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    docItems?: DocItemUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunUncheckedCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    docItems?: DocItemUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUncheckedUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    docItems?: DocItemUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUncheckedUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleAccountCreateInput = {
    id?: string
    googleSub: string
    accessTokenEnc: string
    refreshTokenEnc: string
    expiryDate?: bigint | number | null
    scopes: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGoogleAccountInput
  }

  export type GoogleAccountUncheckedCreateInput = {
    id?: string
    userId: string
    googleSub: string
    accessTokenEnc: string
    refreshTokenEnc: string
    expiryDate?: bigint | number | null
    scopes: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoogleAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleSub?: StringFieldUpdateOperationsInput | string
    accessTokenEnc?: StringFieldUpdateOperationsInput | string
    refreshTokenEnc?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scopes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGoogleAccountNestedInput
  }

  export type GoogleAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    googleSub?: StringFieldUpdateOperationsInput | string
    accessTokenEnc?: StringFieldUpdateOperationsInput | string
    refreshTokenEnc?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scopes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleAccountCreateManyInput = {
    id?: string
    userId: string
    googleSub: string
    accessTokenEnc: string
    refreshTokenEnc: string
    expiryDate?: bigint | number | null
    scopes: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoogleAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleSub?: StringFieldUpdateOperationsInput | string
    accessTokenEnc?: StringFieldUpdateOperationsInput | string
    refreshTokenEnc?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scopes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    googleSub?: StringFieldUpdateOperationsInput | string
    accessTokenEnc?: StringFieldUpdateOperationsInput | string
    refreshTokenEnc?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scopes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailItemCreateInput = {
    id?: string
    gmailId: string
    threadId?: string | null
    from: string
    subject: string
    snippet: string
    receivedAt: Date | string
    isUnread: boolean
    rawJson: string
    user: UserCreateNestedOneWithoutEmailItemsInput
  }

  export type EmailItemUncheckedCreateInput = {
    id?: string
    userId: string
    gmailId: string
    threadId?: string | null
    from: string
    subject: string
    snippet: string
    receivedAt: Date | string
    isUnread: boolean
    rawJson: string
  }

  export type EmailItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailId?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    snippet?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUnread?: BoolFieldUpdateOperationsInput | boolean
    rawJson?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutEmailItemsNestedInput
  }

  export type EmailItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gmailId?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    snippet?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUnread?: BoolFieldUpdateOperationsInput | boolean
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type EmailItemCreateManyInput = {
    id?: string
    userId: string
    gmailId: string
    threadId?: string | null
    from: string
    subject: string
    snippet: string
    receivedAt: Date | string
    isUnread: boolean
    rawJson: string
  }

  export type EmailItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailId?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    snippet?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUnread?: BoolFieldUpdateOperationsInput | boolean
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type EmailItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gmailId?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    snippet?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUnread?: BoolFieldUpdateOperationsInput | boolean
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventCreateInput = {
    id?: string
    gcalId: string
    title: string
    start: Date | string
    end: Date | string
    location?: string | null
    rawJson: string
    user: UserCreateNestedOneWithoutCalendarEventsInput
  }

  export type CalendarEventUncheckedCreateInput = {
    id?: string
    userId: string
    gcalId: string
    title: string
    start: Date | string
    end: Date | string
    location?: string | null
    rawJson: string
  }

  export type CalendarEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutCalendarEventsNestedInput
  }

  export type CalendarEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gcalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventCreateManyInput = {
    id?: string
    userId: string
    gcalId: string
    title: string
    start: Date | string
    end: Date | string
    location?: string | null
    rawJson: string
  }

  export type CalendarEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gcalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type DocItemCreateInput = {
    id?: string
    fileId: string
    title: string
    sourceType: string
    modifiedTime: Date | string
    extractedText?: string | null
    textHash?: string | null
    rawJson: string
    user: UserCreateNestedOneWithoutDocItemsInput
  }

  export type DocItemUncheckedCreateInput = {
    id?: string
    userId: string
    fileId: string
    title: string
    sourceType: string
    modifiedTime: Date | string
    extractedText?: string | null
    textHash?: string | null
    rawJson: string
  }

  export type DocItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    modifiedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    textHash?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDocItemsNestedInput
  }

  export type DocItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    modifiedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    textHash?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type DocItemCreateManyInput = {
    id?: string
    userId: string
    fileId: string
    title: string
    sourceType: string
    modifiedTime: Date | string
    extractedText?: string | null
    textHash?: string | null
    rawJson: string
  }

  export type DocItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    modifiedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    textHash?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type DocItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    modifiedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    textHash?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    sourceType: string
    sourceId?: string | null
    dueAt?: Date | string | null
    estMins?: number | null
    priority: string
    status: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    sourceType: string
    sourceId?: string | null
    dueAt?: Date | string | null
    estMins?: number | null
    priority: string
    status: string
    createdAt?: Date | string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estMins?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estMins?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    sourceType: string
    sourceId?: string | null
    dueAt?: Date | string | null
    estMins?: number | null
    priority: string
    status: string
    createdAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estMins?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estMins?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    id?: string
    weekStartDate: Date | string
    planJson: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPlansInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    userId: string
    weekStartDate: Date | string
    planJson: string
    createdAt?: Date | string
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlansNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateManyInput = {
    id?: string
    userId: string
    weekStartDate: Date | string
    planJson: string
    createdAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriageRunCreateInput = {
    id?: string
    createdAt?: Date | string
    resultJson: string
    user: UserCreateNestedOneWithoutTriageRunsInput
  }

  export type TriageRunUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    resultJson: string
  }

  export type TriageRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultJson?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTriageRunsNestedInput
  }

  export type TriageRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultJson?: StringFieldUpdateOperationsInput | string
  }

  export type TriageRunCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    resultJson: string
  }

  export type TriageRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultJson?: StringFieldUpdateOperationsInput | string
  }

  export type TriageRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultJson?: StringFieldUpdateOperationsInput | string
  }

  export type LearningMaterialCreateInput = {
    id?: string
    filename: string
    fileType: string
    extractedText?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLearningMaterialsInput
    artifacts?: LearningArtifactCreateNestedManyWithoutLearningMaterialInput
  }

  export type LearningMaterialUncheckedCreateInput = {
    id?: string
    userId: string
    filename: string
    fileType: string
    extractedText?: string | null
    createdAt?: Date | string
    artifacts?: LearningArtifactUncheckedCreateNestedManyWithoutLearningMaterialInput
  }

  export type LearningMaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLearningMaterialsNestedInput
    artifacts?: LearningArtifactUpdateManyWithoutLearningMaterialNestedInput
  }

  export type LearningMaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: LearningArtifactUncheckedUpdateManyWithoutLearningMaterialNestedInput
  }

  export type LearningMaterialCreateManyInput = {
    id?: string
    userId: string
    filename: string
    fileType: string
    extractedText?: string | null
    createdAt?: Date | string
  }

  export type LearningMaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningMaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningArtifactCreateInput = {
    id?: string
    type: string
    artifactJson: string
    createdAt?: Date | string
    learningMaterial: LearningMaterialCreateNestedOneWithoutArtifactsInput
  }

  export type LearningArtifactUncheckedCreateInput = {
    id?: string
    learningMaterialId: string
    type: string
    artifactJson: string
    createdAt?: Date | string
  }

  export type LearningArtifactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    artifactJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learningMaterial?: LearningMaterialUpdateOneRequiredWithoutArtifactsNestedInput
  }

  export type LearningArtifactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    learningMaterialId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    artifactJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningArtifactCreateManyInput = {
    id?: string
    learningMaterialId: string
    type: string
    artifactJson: string
    createdAt?: Date | string
  }

  export type LearningArtifactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    artifactJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningArtifactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    learningMaterialId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    artifactJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type GoogleAccountNullableRelationFilter = {
    is?: GoogleAccountWhereInput | null
    isNot?: GoogleAccountWhereInput | null
  }

  export type EmailItemListRelationFilter = {
    every?: EmailItemWhereInput
    some?: EmailItemWhereInput
    none?: EmailItemWhereInput
  }

  export type CalendarEventListRelationFilter = {
    every?: CalendarEventWhereInput
    some?: CalendarEventWhereInput
    none?: CalendarEventWhereInput
  }

  export type DocItemListRelationFilter = {
    every?: DocItemWhereInput
    some?: DocItemWhereInput
    none?: DocItemWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type PlanListRelationFilter = {
    every?: PlanWhereInput
    some?: PlanWhereInput
    none?: PlanWhereInput
  }

  export type TriageRunListRelationFilter = {
    every?: TriageRunWhereInput
    some?: TriageRunWhereInput
    none?: TriageRunWhereInput
  }

  export type LearningMaterialListRelationFilter = {
    every?: LearningMaterialWhereInput
    some?: LearningMaterialWhereInput
    none?: LearningMaterialWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EmailItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TriageRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type GoogleAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    googleSub?: SortOrder
    accessTokenEnc?: SortOrder
    refreshTokenEnc?: SortOrder
    expiryDate?: SortOrder
    scopes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoogleAccountAvgOrderByAggregateInput = {
    expiryDate?: SortOrder
  }

  export type GoogleAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    googleSub?: SortOrder
    accessTokenEnc?: SortOrder
    refreshTokenEnc?: SortOrder
    expiryDate?: SortOrder
    scopes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoogleAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    googleSub?: SortOrder
    accessTokenEnc?: SortOrder
    refreshTokenEnc?: SortOrder
    expiryDate?: SortOrder
    scopes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoogleAccountSumOrderByAggregateInput = {
    expiryDate?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EmailItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gmailId?: SortOrder
    threadId?: SortOrder
    from?: SortOrder
    subject?: SortOrder
    snippet?: SortOrder
    receivedAt?: SortOrder
    isUnread?: SortOrder
    rawJson?: SortOrder
  }

  export type EmailItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gmailId?: SortOrder
    threadId?: SortOrder
    from?: SortOrder
    subject?: SortOrder
    snippet?: SortOrder
    receivedAt?: SortOrder
    isUnread?: SortOrder
    rawJson?: SortOrder
  }

  export type EmailItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gmailId?: SortOrder
    threadId?: SortOrder
    from?: SortOrder
    subject?: SortOrder
    snippet?: SortOrder
    receivedAt?: SortOrder
    isUnread?: SortOrder
    rawJson?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CalendarEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gcalId?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    location?: SortOrder
    rawJson?: SortOrder
  }

  export type CalendarEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gcalId?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    location?: SortOrder
    rawJson?: SortOrder
  }

  export type CalendarEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gcalId?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    location?: SortOrder
    rawJson?: SortOrder
  }

  export type DocItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fileId?: SortOrder
    title?: SortOrder
    sourceType?: SortOrder
    modifiedTime?: SortOrder
    extractedText?: SortOrder
    textHash?: SortOrder
    rawJson?: SortOrder
  }

  export type DocItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fileId?: SortOrder
    title?: SortOrder
    sourceType?: SortOrder
    modifiedTime?: SortOrder
    extractedText?: SortOrder
    textHash?: SortOrder
    rawJson?: SortOrder
  }

  export type DocItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fileId?: SortOrder
    title?: SortOrder
    sourceType?: SortOrder
    modifiedTime?: SortOrder
    extractedText?: SortOrder
    textHash?: SortOrder
    rawJson?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    dueAt?: SortOrder
    estMins?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    estMins?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    dueAt?: SortOrder
    estMins?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    dueAt?: SortOrder
    estMins?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    estMins?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weekStartDate?: SortOrder
    planJson?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weekStartDate?: SortOrder
    planJson?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weekStartDate?: SortOrder
    planJson?: SortOrder
    createdAt?: SortOrder
  }

  export type TriageRunCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    resultJson?: SortOrder
  }

  export type TriageRunMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    resultJson?: SortOrder
  }

  export type TriageRunMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    resultJson?: SortOrder
  }

  export type LearningArtifactListRelationFilter = {
    every?: LearningArtifactWhereInput
    some?: LearningArtifactWhereInput
    none?: LearningArtifactWhereInput
  }

  export type LearningArtifactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    extractedText?: SortOrder
    createdAt?: SortOrder
  }

  export type LearningMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    extractedText?: SortOrder
    createdAt?: SortOrder
  }

  export type LearningMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    extractedText?: SortOrder
    createdAt?: SortOrder
  }

  export type LearningMaterialRelationFilter = {
    is?: LearningMaterialWhereInput
    isNot?: LearningMaterialWhereInput
  }

  export type LearningArtifactCountOrderByAggregateInput = {
    id?: SortOrder
    learningMaterialId?: SortOrder
    type?: SortOrder
    artifactJson?: SortOrder
    createdAt?: SortOrder
  }

  export type LearningArtifactMaxOrderByAggregateInput = {
    id?: SortOrder
    learningMaterialId?: SortOrder
    type?: SortOrder
    artifactJson?: SortOrder
    createdAt?: SortOrder
  }

  export type LearningArtifactMinOrderByAggregateInput = {
    id?: SortOrder
    learningMaterialId?: SortOrder
    type?: SortOrder
    artifactJson?: SortOrder
    createdAt?: SortOrder
  }

  export type GoogleAccountCreateNestedOneWithoutUserInput = {
    create?: XOR<GoogleAccountCreateWithoutUserInput, GoogleAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleAccountCreateOrConnectWithoutUserInput
    connect?: GoogleAccountWhereUniqueInput
  }

  export type EmailItemCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailItemCreateWithoutUserInput, EmailItemUncheckedCreateWithoutUserInput> | EmailItemCreateWithoutUserInput[] | EmailItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailItemCreateOrConnectWithoutUserInput | EmailItemCreateOrConnectWithoutUserInput[]
    createMany?: EmailItemCreateManyUserInputEnvelope
    connect?: EmailItemWhereUniqueInput | EmailItemWhereUniqueInput[]
  }

  export type CalendarEventCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type DocItemCreateNestedManyWithoutUserInput = {
    create?: XOR<DocItemCreateWithoutUserInput, DocItemUncheckedCreateWithoutUserInput> | DocItemCreateWithoutUserInput[] | DocItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocItemCreateOrConnectWithoutUserInput | DocItemCreateOrConnectWithoutUserInput[]
    createMany?: DocItemCreateManyUserInputEnvelope
    connect?: DocItemWhereUniqueInput | DocItemWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type PlanCreateNestedManyWithoutUserInput = {
    create?: XOR<PlanCreateWithoutUserInput, PlanUncheckedCreateWithoutUserInput> | PlanCreateWithoutUserInput[] | PlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutUserInput | PlanCreateOrConnectWithoutUserInput[]
    createMany?: PlanCreateManyUserInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type TriageRunCreateNestedManyWithoutUserInput = {
    create?: XOR<TriageRunCreateWithoutUserInput, TriageRunUncheckedCreateWithoutUserInput> | TriageRunCreateWithoutUserInput[] | TriageRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TriageRunCreateOrConnectWithoutUserInput | TriageRunCreateOrConnectWithoutUserInput[]
    createMany?: TriageRunCreateManyUserInputEnvelope
    connect?: TriageRunWhereUniqueInput | TriageRunWhereUniqueInput[]
  }

  export type LearningMaterialCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningMaterialCreateWithoutUserInput, LearningMaterialUncheckedCreateWithoutUserInput> | LearningMaterialCreateWithoutUserInput[] | LearningMaterialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningMaterialCreateOrConnectWithoutUserInput | LearningMaterialCreateOrConnectWithoutUserInput[]
    createMany?: LearningMaterialCreateManyUserInputEnvelope
    connect?: LearningMaterialWhereUniqueInput | LearningMaterialWhereUniqueInput[]
  }

  export type GoogleAccountUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<GoogleAccountCreateWithoutUserInput, GoogleAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleAccountCreateOrConnectWithoutUserInput
    connect?: GoogleAccountWhereUniqueInput
  }

  export type EmailItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailItemCreateWithoutUserInput, EmailItemUncheckedCreateWithoutUserInput> | EmailItemCreateWithoutUserInput[] | EmailItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailItemCreateOrConnectWithoutUserInput | EmailItemCreateOrConnectWithoutUserInput[]
    createMany?: EmailItemCreateManyUserInputEnvelope
    connect?: EmailItemWhereUniqueInput | EmailItemWhereUniqueInput[]
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type DocItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocItemCreateWithoutUserInput, DocItemUncheckedCreateWithoutUserInput> | DocItemCreateWithoutUserInput[] | DocItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocItemCreateOrConnectWithoutUserInput | DocItemCreateOrConnectWithoutUserInput[]
    createMany?: DocItemCreateManyUserInputEnvelope
    connect?: DocItemWhereUniqueInput | DocItemWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type PlanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlanCreateWithoutUserInput, PlanUncheckedCreateWithoutUserInput> | PlanCreateWithoutUserInput[] | PlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutUserInput | PlanCreateOrConnectWithoutUserInput[]
    createMany?: PlanCreateManyUserInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type TriageRunUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TriageRunCreateWithoutUserInput, TriageRunUncheckedCreateWithoutUserInput> | TriageRunCreateWithoutUserInput[] | TriageRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TriageRunCreateOrConnectWithoutUserInput | TriageRunCreateOrConnectWithoutUserInput[]
    createMany?: TriageRunCreateManyUserInputEnvelope
    connect?: TriageRunWhereUniqueInput | TriageRunWhereUniqueInput[]
  }

  export type LearningMaterialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningMaterialCreateWithoutUserInput, LearningMaterialUncheckedCreateWithoutUserInput> | LearningMaterialCreateWithoutUserInput[] | LearningMaterialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningMaterialCreateOrConnectWithoutUserInput | LearningMaterialCreateOrConnectWithoutUserInput[]
    createMany?: LearningMaterialCreateManyUserInputEnvelope
    connect?: LearningMaterialWhereUniqueInput | LearningMaterialWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type GoogleAccountUpdateOneWithoutUserNestedInput = {
    create?: XOR<GoogleAccountCreateWithoutUserInput, GoogleAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleAccountCreateOrConnectWithoutUserInput
    upsert?: GoogleAccountUpsertWithoutUserInput
    disconnect?: GoogleAccountWhereInput | boolean
    delete?: GoogleAccountWhereInput | boolean
    connect?: GoogleAccountWhereUniqueInput
    update?: XOR<XOR<GoogleAccountUpdateToOneWithWhereWithoutUserInput, GoogleAccountUpdateWithoutUserInput>, GoogleAccountUncheckedUpdateWithoutUserInput>
  }

  export type EmailItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailItemCreateWithoutUserInput, EmailItemUncheckedCreateWithoutUserInput> | EmailItemCreateWithoutUserInput[] | EmailItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailItemCreateOrConnectWithoutUserInput | EmailItemCreateOrConnectWithoutUserInput[]
    upsert?: EmailItemUpsertWithWhereUniqueWithoutUserInput | EmailItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailItemCreateManyUserInputEnvelope
    set?: EmailItemWhereUniqueInput | EmailItemWhereUniqueInput[]
    disconnect?: EmailItemWhereUniqueInput | EmailItemWhereUniqueInput[]
    delete?: EmailItemWhereUniqueInput | EmailItemWhereUniqueInput[]
    connect?: EmailItemWhereUniqueInput | EmailItemWhereUniqueInput[]
    update?: EmailItemUpdateWithWhereUniqueWithoutUserInput | EmailItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailItemUpdateManyWithWhereWithoutUserInput | EmailItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailItemScalarWhereInput | EmailItemScalarWhereInput[]
  }

  export type CalendarEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutUserInput | CalendarEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutUserInput | CalendarEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutUserInput | CalendarEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type DocItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocItemCreateWithoutUserInput, DocItemUncheckedCreateWithoutUserInput> | DocItemCreateWithoutUserInput[] | DocItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocItemCreateOrConnectWithoutUserInput | DocItemCreateOrConnectWithoutUserInput[]
    upsert?: DocItemUpsertWithWhereUniqueWithoutUserInput | DocItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocItemCreateManyUserInputEnvelope
    set?: DocItemWhereUniqueInput | DocItemWhereUniqueInput[]
    disconnect?: DocItemWhereUniqueInput | DocItemWhereUniqueInput[]
    delete?: DocItemWhereUniqueInput | DocItemWhereUniqueInput[]
    connect?: DocItemWhereUniqueInput | DocItemWhereUniqueInput[]
    update?: DocItemUpdateWithWhereUniqueWithoutUserInput | DocItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocItemUpdateManyWithWhereWithoutUserInput | DocItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocItemScalarWhereInput | DocItemScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserInput | TaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserInput | TaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserInput | TaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type PlanUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlanCreateWithoutUserInput, PlanUncheckedCreateWithoutUserInput> | PlanCreateWithoutUserInput[] | PlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutUserInput | PlanCreateOrConnectWithoutUserInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutUserInput | PlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlanCreateManyUserInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutUserInput | PlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutUserInput | PlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type TriageRunUpdateManyWithoutUserNestedInput = {
    create?: XOR<TriageRunCreateWithoutUserInput, TriageRunUncheckedCreateWithoutUserInput> | TriageRunCreateWithoutUserInput[] | TriageRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TriageRunCreateOrConnectWithoutUserInput | TriageRunCreateOrConnectWithoutUserInput[]
    upsert?: TriageRunUpsertWithWhereUniqueWithoutUserInput | TriageRunUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TriageRunCreateManyUserInputEnvelope
    set?: TriageRunWhereUniqueInput | TriageRunWhereUniqueInput[]
    disconnect?: TriageRunWhereUniqueInput | TriageRunWhereUniqueInput[]
    delete?: TriageRunWhereUniqueInput | TriageRunWhereUniqueInput[]
    connect?: TriageRunWhereUniqueInput | TriageRunWhereUniqueInput[]
    update?: TriageRunUpdateWithWhereUniqueWithoutUserInput | TriageRunUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TriageRunUpdateManyWithWhereWithoutUserInput | TriageRunUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TriageRunScalarWhereInput | TriageRunScalarWhereInput[]
  }

  export type LearningMaterialUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningMaterialCreateWithoutUserInput, LearningMaterialUncheckedCreateWithoutUserInput> | LearningMaterialCreateWithoutUserInput[] | LearningMaterialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningMaterialCreateOrConnectWithoutUserInput | LearningMaterialCreateOrConnectWithoutUserInput[]
    upsert?: LearningMaterialUpsertWithWhereUniqueWithoutUserInput | LearningMaterialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningMaterialCreateManyUserInputEnvelope
    set?: LearningMaterialWhereUniqueInput | LearningMaterialWhereUniqueInput[]
    disconnect?: LearningMaterialWhereUniqueInput | LearningMaterialWhereUniqueInput[]
    delete?: LearningMaterialWhereUniqueInput | LearningMaterialWhereUniqueInput[]
    connect?: LearningMaterialWhereUniqueInput | LearningMaterialWhereUniqueInput[]
    update?: LearningMaterialUpdateWithWhereUniqueWithoutUserInput | LearningMaterialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningMaterialUpdateManyWithWhereWithoutUserInput | LearningMaterialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningMaterialScalarWhereInput | LearningMaterialScalarWhereInput[]
  }

  export type GoogleAccountUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<GoogleAccountCreateWithoutUserInput, GoogleAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleAccountCreateOrConnectWithoutUserInput
    upsert?: GoogleAccountUpsertWithoutUserInput
    disconnect?: GoogleAccountWhereInput | boolean
    delete?: GoogleAccountWhereInput | boolean
    connect?: GoogleAccountWhereUniqueInput
    update?: XOR<XOR<GoogleAccountUpdateToOneWithWhereWithoutUserInput, GoogleAccountUpdateWithoutUserInput>, GoogleAccountUncheckedUpdateWithoutUserInput>
  }

  export type EmailItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailItemCreateWithoutUserInput, EmailItemUncheckedCreateWithoutUserInput> | EmailItemCreateWithoutUserInput[] | EmailItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailItemCreateOrConnectWithoutUserInput | EmailItemCreateOrConnectWithoutUserInput[]
    upsert?: EmailItemUpsertWithWhereUniqueWithoutUserInput | EmailItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailItemCreateManyUserInputEnvelope
    set?: EmailItemWhereUniqueInput | EmailItemWhereUniqueInput[]
    disconnect?: EmailItemWhereUniqueInput | EmailItemWhereUniqueInput[]
    delete?: EmailItemWhereUniqueInput | EmailItemWhereUniqueInput[]
    connect?: EmailItemWhereUniqueInput | EmailItemWhereUniqueInput[]
    update?: EmailItemUpdateWithWhereUniqueWithoutUserInput | EmailItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailItemUpdateManyWithWhereWithoutUserInput | EmailItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailItemScalarWhereInput | EmailItemScalarWhereInput[]
  }

  export type CalendarEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutUserInput | CalendarEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutUserInput | CalendarEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutUserInput | CalendarEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type DocItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocItemCreateWithoutUserInput, DocItemUncheckedCreateWithoutUserInput> | DocItemCreateWithoutUserInput[] | DocItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocItemCreateOrConnectWithoutUserInput | DocItemCreateOrConnectWithoutUserInput[]
    upsert?: DocItemUpsertWithWhereUniqueWithoutUserInput | DocItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocItemCreateManyUserInputEnvelope
    set?: DocItemWhereUniqueInput | DocItemWhereUniqueInput[]
    disconnect?: DocItemWhereUniqueInput | DocItemWhereUniqueInput[]
    delete?: DocItemWhereUniqueInput | DocItemWhereUniqueInput[]
    connect?: DocItemWhereUniqueInput | DocItemWhereUniqueInput[]
    update?: DocItemUpdateWithWhereUniqueWithoutUserInput | DocItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocItemUpdateManyWithWhereWithoutUserInput | DocItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocItemScalarWhereInput | DocItemScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserInput | TaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserInput | TaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserInput | TaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type PlanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlanCreateWithoutUserInput, PlanUncheckedCreateWithoutUserInput> | PlanCreateWithoutUserInput[] | PlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutUserInput | PlanCreateOrConnectWithoutUserInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutUserInput | PlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlanCreateManyUserInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutUserInput | PlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutUserInput | PlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type TriageRunUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TriageRunCreateWithoutUserInput, TriageRunUncheckedCreateWithoutUserInput> | TriageRunCreateWithoutUserInput[] | TriageRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TriageRunCreateOrConnectWithoutUserInput | TriageRunCreateOrConnectWithoutUserInput[]
    upsert?: TriageRunUpsertWithWhereUniqueWithoutUserInput | TriageRunUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TriageRunCreateManyUserInputEnvelope
    set?: TriageRunWhereUniqueInput | TriageRunWhereUniqueInput[]
    disconnect?: TriageRunWhereUniqueInput | TriageRunWhereUniqueInput[]
    delete?: TriageRunWhereUniqueInput | TriageRunWhereUniqueInput[]
    connect?: TriageRunWhereUniqueInput | TriageRunWhereUniqueInput[]
    update?: TriageRunUpdateWithWhereUniqueWithoutUserInput | TriageRunUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TriageRunUpdateManyWithWhereWithoutUserInput | TriageRunUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TriageRunScalarWhereInput | TriageRunScalarWhereInput[]
  }

  export type LearningMaterialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningMaterialCreateWithoutUserInput, LearningMaterialUncheckedCreateWithoutUserInput> | LearningMaterialCreateWithoutUserInput[] | LearningMaterialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningMaterialCreateOrConnectWithoutUserInput | LearningMaterialCreateOrConnectWithoutUserInput[]
    upsert?: LearningMaterialUpsertWithWhereUniqueWithoutUserInput | LearningMaterialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningMaterialCreateManyUserInputEnvelope
    set?: LearningMaterialWhereUniqueInput | LearningMaterialWhereUniqueInput[]
    disconnect?: LearningMaterialWhereUniqueInput | LearningMaterialWhereUniqueInput[]
    delete?: LearningMaterialWhereUniqueInput | LearningMaterialWhereUniqueInput[]
    connect?: LearningMaterialWhereUniqueInput | LearningMaterialWhereUniqueInput[]
    update?: LearningMaterialUpdateWithWhereUniqueWithoutUserInput | LearningMaterialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningMaterialUpdateManyWithWhereWithoutUserInput | LearningMaterialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningMaterialScalarWhereInput | LearningMaterialScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutGoogleAccountInput = {
    create?: XOR<UserCreateWithoutGoogleAccountInput, UserUncheckedCreateWithoutGoogleAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutGoogleAccountInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneRequiredWithoutGoogleAccountNestedInput = {
    create?: XOR<UserCreateWithoutGoogleAccountInput, UserUncheckedCreateWithoutGoogleAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutGoogleAccountInput
    upsert?: UserUpsertWithoutGoogleAccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGoogleAccountInput, UserUpdateWithoutGoogleAccountInput>, UserUncheckedUpdateWithoutGoogleAccountInput>
  }

  export type UserCreateNestedOneWithoutEmailItemsInput = {
    create?: XOR<UserCreateWithoutEmailItemsInput, UserUncheckedCreateWithoutEmailItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailItemsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutEmailItemsNestedInput = {
    create?: XOR<UserCreateWithoutEmailItemsInput, UserUncheckedCreateWithoutEmailItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailItemsInput
    upsert?: UserUpsertWithoutEmailItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailItemsInput, UserUpdateWithoutEmailItemsInput>, UserUncheckedUpdateWithoutEmailItemsInput>
  }

  export type UserCreateNestedOneWithoutCalendarEventsInput = {
    create?: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCalendarEventsNestedInput = {
    create?: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarEventsInput
    upsert?: UserUpsertWithoutCalendarEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCalendarEventsInput, UserUpdateWithoutCalendarEventsInput>, UserUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type UserCreateNestedOneWithoutDocItemsInput = {
    create?: XOR<UserCreateWithoutDocItemsInput, UserUncheckedCreateWithoutDocItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocItemsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDocItemsNestedInput = {
    create?: XOR<UserCreateWithoutDocItemsInput, UserUncheckedCreateWithoutDocItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocItemsInput
    upsert?: UserUpsertWithoutDocItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocItemsInput, UserUpdateWithoutDocItemsInput>, UserUncheckedUpdateWithoutDocItemsInput>
  }

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    upsert?: UserUpsertWithoutTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksInput, UserUpdateWithoutTasksInput>, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserCreateNestedOneWithoutPlansInput = {
    create?: XOR<UserCreateWithoutPlansInput, UserUncheckedCreateWithoutPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlansInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPlansNestedInput = {
    create?: XOR<UserCreateWithoutPlansInput, UserUncheckedCreateWithoutPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlansInput
    upsert?: UserUpsertWithoutPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlansInput, UserUpdateWithoutPlansInput>, UserUncheckedUpdateWithoutPlansInput>
  }

  export type UserCreateNestedOneWithoutTriageRunsInput = {
    create?: XOR<UserCreateWithoutTriageRunsInput, UserUncheckedCreateWithoutTriageRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTriageRunsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTriageRunsNestedInput = {
    create?: XOR<UserCreateWithoutTriageRunsInput, UserUncheckedCreateWithoutTriageRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTriageRunsInput
    upsert?: UserUpsertWithoutTriageRunsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTriageRunsInput, UserUpdateWithoutTriageRunsInput>, UserUncheckedUpdateWithoutTriageRunsInput>
  }

  export type UserCreateNestedOneWithoutLearningMaterialsInput = {
    create?: XOR<UserCreateWithoutLearningMaterialsInput, UserUncheckedCreateWithoutLearningMaterialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningMaterialsInput
    connect?: UserWhereUniqueInput
  }

  export type LearningArtifactCreateNestedManyWithoutLearningMaterialInput = {
    create?: XOR<LearningArtifactCreateWithoutLearningMaterialInput, LearningArtifactUncheckedCreateWithoutLearningMaterialInput> | LearningArtifactCreateWithoutLearningMaterialInput[] | LearningArtifactUncheckedCreateWithoutLearningMaterialInput[]
    connectOrCreate?: LearningArtifactCreateOrConnectWithoutLearningMaterialInput | LearningArtifactCreateOrConnectWithoutLearningMaterialInput[]
    createMany?: LearningArtifactCreateManyLearningMaterialInputEnvelope
    connect?: LearningArtifactWhereUniqueInput | LearningArtifactWhereUniqueInput[]
  }

  export type LearningArtifactUncheckedCreateNestedManyWithoutLearningMaterialInput = {
    create?: XOR<LearningArtifactCreateWithoutLearningMaterialInput, LearningArtifactUncheckedCreateWithoutLearningMaterialInput> | LearningArtifactCreateWithoutLearningMaterialInput[] | LearningArtifactUncheckedCreateWithoutLearningMaterialInput[]
    connectOrCreate?: LearningArtifactCreateOrConnectWithoutLearningMaterialInput | LearningArtifactCreateOrConnectWithoutLearningMaterialInput[]
    createMany?: LearningArtifactCreateManyLearningMaterialInputEnvelope
    connect?: LearningArtifactWhereUniqueInput | LearningArtifactWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLearningMaterialsNestedInput = {
    create?: XOR<UserCreateWithoutLearningMaterialsInput, UserUncheckedCreateWithoutLearningMaterialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningMaterialsInput
    upsert?: UserUpsertWithoutLearningMaterialsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLearningMaterialsInput, UserUpdateWithoutLearningMaterialsInput>, UserUncheckedUpdateWithoutLearningMaterialsInput>
  }

  export type LearningArtifactUpdateManyWithoutLearningMaterialNestedInput = {
    create?: XOR<LearningArtifactCreateWithoutLearningMaterialInput, LearningArtifactUncheckedCreateWithoutLearningMaterialInput> | LearningArtifactCreateWithoutLearningMaterialInput[] | LearningArtifactUncheckedCreateWithoutLearningMaterialInput[]
    connectOrCreate?: LearningArtifactCreateOrConnectWithoutLearningMaterialInput | LearningArtifactCreateOrConnectWithoutLearningMaterialInput[]
    upsert?: LearningArtifactUpsertWithWhereUniqueWithoutLearningMaterialInput | LearningArtifactUpsertWithWhereUniqueWithoutLearningMaterialInput[]
    createMany?: LearningArtifactCreateManyLearningMaterialInputEnvelope
    set?: LearningArtifactWhereUniqueInput | LearningArtifactWhereUniqueInput[]
    disconnect?: LearningArtifactWhereUniqueInput | LearningArtifactWhereUniqueInput[]
    delete?: LearningArtifactWhereUniqueInput | LearningArtifactWhereUniqueInput[]
    connect?: LearningArtifactWhereUniqueInput | LearningArtifactWhereUniqueInput[]
    update?: LearningArtifactUpdateWithWhereUniqueWithoutLearningMaterialInput | LearningArtifactUpdateWithWhereUniqueWithoutLearningMaterialInput[]
    updateMany?: LearningArtifactUpdateManyWithWhereWithoutLearningMaterialInput | LearningArtifactUpdateManyWithWhereWithoutLearningMaterialInput[]
    deleteMany?: LearningArtifactScalarWhereInput | LearningArtifactScalarWhereInput[]
  }

  export type LearningArtifactUncheckedUpdateManyWithoutLearningMaterialNestedInput = {
    create?: XOR<LearningArtifactCreateWithoutLearningMaterialInput, LearningArtifactUncheckedCreateWithoutLearningMaterialInput> | LearningArtifactCreateWithoutLearningMaterialInput[] | LearningArtifactUncheckedCreateWithoutLearningMaterialInput[]
    connectOrCreate?: LearningArtifactCreateOrConnectWithoutLearningMaterialInput | LearningArtifactCreateOrConnectWithoutLearningMaterialInput[]
    upsert?: LearningArtifactUpsertWithWhereUniqueWithoutLearningMaterialInput | LearningArtifactUpsertWithWhereUniqueWithoutLearningMaterialInput[]
    createMany?: LearningArtifactCreateManyLearningMaterialInputEnvelope
    set?: LearningArtifactWhereUniqueInput | LearningArtifactWhereUniqueInput[]
    disconnect?: LearningArtifactWhereUniqueInput | LearningArtifactWhereUniqueInput[]
    delete?: LearningArtifactWhereUniqueInput | LearningArtifactWhereUniqueInput[]
    connect?: LearningArtifactWhereUniqueInput | LearningArtifactWhereUniqueInput[]
    update?: LearningArtifactUpdateWithWhereUniqueWithoutLearningMaterialInput | LearningArtifactUpdateWithWhereUniqueWithoutLearningMaterialInput[]
    updateMany?: LearningArtifactUpdateManyWithWhereWithoutLearningMaterialInput | LearningArtifactUpdateManyWithWhereWithoutLearningMaterialInput[]
    deleteMany?: LearningArtifactScalarWhereInput | LearningArtifactScalarWhereInput[]
  }

  export type LearningMaterialCreateNestedOneWithoutArtifactsInput = {
    create?: XOR<LearningMaterialCreateWithoutArtifactsInput, LearningMaterialUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: LearningMaterialCreateOrConnectWithoutArtifactsInput
    connect?: LearningMaterialWhereUniqueInput
  }

  export type LearningMaterialUpdateOneRequiredWithoutArtifactsNestedInput = {
    create?: XOR<LearningMaterialCreateWithoutArtifactsInput, LearningMaterialUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: LearningMaterialCreateOrConnectWithoutArtifactsInput
    upsert?: LearningMaterialUpsertWithoutArtifactsInput
    connect?: LearningMaterialWhereUniqueInput
    update?: XOR<XOR<LearningMaterialUpdateToOneWithWhereWithoutArtifactsInput, LearningMaterialUpdateWithoutArtifactsInput>, LearningMaterialUncheckedUpdateWithoutArtifactsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type GoogleAccountCreateWithoutUserInput = {
    id?: string
    googleSub: string
    accessTokenEnc: string
    refreshTokenEnc: string
    expiryDate?: bigint | number | null
    scopes: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoogleAccountUncheckedCreateWithoutUserInput = {
    id?: string
    googleSub: string
    accessTokenEnc: string
    refreshTokenEnc: string
    expiryDate?: bigint | number | null
    scopes: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoogleAccountCreateOrConnectWithoutUserInput = {
    where: GoogleAccountWhereUniqueInput
    create: XOR<GoogleAccountCreateWithoutUserInput, GoogleAccountUncheckedCreateWithoutUserInput>
  }

  export type EmailItemCreateWithoutUserInput = {
    id?: string
    gmailId: string
    threadId?: string | null
    from: string
    subject: string
    snippet: string
    receivedAt: Date | string
    isUnread: boolean
    rawJson: string
  }

  export type EmailItemUncheckedCreateWithoutUserInput = {
    id?: string
    gmailId: string
    threadId?: string | null
    from: string
    subject: string
    snippet: string
    receivedAt: Date | string
    isUnread: boolean
    rawJson: string
  }

  export type EmailItemCreateOrConnectWithoutUserInput = {
    where: EmailItemWhereUniqueInput
    create: XOR<EmailItemCreateWithoutUserInput, EmailItemUncheckedCreateWithoutUserInput>
  }

  export type EmailItemCreateManyUserInputEnvelope = {
    data: EmailItemCreateManyUserInput | EmailItemCreateManyUserInput[]
  }

  export type CalendarEventCreateWithoutUserInput = {
    id?: string
    gcalId: string
    title: string
    start: Date | string
    end: Date | string
    location?: string | null
    rawJson: string
  }

  export type CalendarEventUncheckedCreateWithoutUserInput = {
    id?: string
    gcalId: string
    title: string
    start: Date | string
    end: Date | string
    location?: string | null
    rawJson: string
  }

  export type CalendarEventCreateOrConnectWithoutUserInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput>
  }

  export type CalendarEventCreateManyUserInputEnvelope = {
    data: CalendarEventCreateManyUserInput | CalendarEventCreateManyUserInput[]
  }

  export type DocItemCreateWithoutUserInput = {
    id?: string
    fileId: string
    title: string
    sourceType: string
    modifiedTime: Date | string
    extractedText?: string | null
    textHash?: string | null
    rawJson: string
  }

  export type DocItemUncheckedCreateWithoutUserInput = {
    id?: string
    fileId: string
    title: string
    sourceType: string
    modifiedTime: Date | string
    extractedText?: string | null
    textHash?: string | null
    rawJson: string
  }

  export type DocItemCreateOrConnectWithoutUserInput = {
    where: DocItemWhereUniqueInput
    create: XOR<DocItemCreateWithoutUserInput, DocItemUncheckedCreateWithoutUserInput>
  }

  export type DocItemCreateManyUserInputEnvelope = {
    data: DocItemCreateManyUserInput | DocItemCreateManyUserInput[]
  }

  export type TaskCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    sourceType: string
    sourceId?: string | null
    dueAt?: Date | string | null
    estMins?: number | null
    priority: string
    status: string
    createdAt?: Date | string
  }

  export type TaskUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    sourceType: string
    sourceId?: string | null
    dueAt?: Date | string | null
    estMins?: number | null
    priority: string
    status: string
    createdAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutUserInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput>
  }

  export type TaskCreateManyUserInputEnvelope = {
    data: TaskCreateManyUserInput | TaskCreateManyUserInput[]
  }

  export type PlanCreateWithoutUserInput = {
    id?: string
    weekStartDate: Date | string
    planJson: string
    createdAt?: Date | string
  }

  export type PlanUncheckedCreateWithoutUserInput = {
    id?: string
    weekStartDate: Date | string
    planJson: string
    createdAt?: Date | string
  }

  export type PlanCreateOrConnectWithoutUserInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutUserInput, PlanUncheckedCreateWithoutUserInput>
  }

  export type PlanCreateManyUserInputEnvelope = {
    data: PlanCreateManyUserInput | PlanCreateManyUserInput[]
  }

  export type TriageRunCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    resultJson: string
  }

  export type TriageRunUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    resultJson: string
  }

  export type TriageRunCreateOrConnectWithoutUserInput = {
    where: TriageRunWhereUniqueInput
    create: XOR<TriageRunCreateWithoutUserInput, TriageRunUncheckedCreateWithoutUserInput>
  }

  export type TriageRunCreateManyUserInputEnvelope = {
    data: TriageRunCreateManyUserInput | TriageRunCreateManyUserInput[]
  }

  export type LearningMaterialCreateWithoutUserInput = {
    id?: string
    filename: string
    fileType: string
    extractedText?: string | null
    createdAt?: Date | string
    artifacts?: LearningArtifactCreateNestedManyWithoutLearningMaterialInput
  }

  export type LearningMaterialUncheckedCreateWithoutUserInput = {
    id?: string
    filename: string
    fileType: string
    extractedText?: string | null
    createdAt?: Date | string
    artifacts?: LearningArtifactUncheckedCreateNestedManyWithoutLearningMaterialInput
  }

  export type LearningMaterialCreateOrConnectWithoutUserInput = {
    where: LearningMaterialWhereUniqueInput
    create: XOR<LearningMaterialCreateWithoutUserInput, LearningMaterialUncheckedCreateWithoutUserInput>
  }

  export type LearningMaterialCreateManyUserInputEnvelope = {
    data: LearningMaterialCreateManyUserInput | LearningMaterialCreateManyUserInput[]
  }

  export type GoogleAccountUpsertWithoutUserInput = {
    update: XOR<GoogleAccountUpdateWithoutUserInput, GoogleAccountUncheckedUpdateWithoutUserInput>
    create: XOR<GoogleAccountCreateWithoutUserInput, GoogleAccountUncheckedCreateWithoutUserInput>
    where?: GoogleAccountWhereInput
  }

  export type GoogleAccountUpdateToOneWithWhereWithoutUserInput = {
    where?: GoogleAccountWhereInput
    data: XOR<GoogleAccountUpdateWithoutUserInput, GoogleAccountUncheckedUpdateWithoutUserInput>
  }

  export type GoogleAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleSub?: StringFieldUpdateOperationsInput | string
    accessTokenEnc?: StringFieldUpdateOperationsInput | string
    refreshTokenEnc?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scopes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleSub?: StringFieldUpdateOperationsInput | string
    accessTokenEnc?: StringFieldUpdateOperationsInput | string
    refreshTokenEnc?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scopes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailItemUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailItemWhereUniqueInput
    update: XOR<EmailItemUpdateWithoutUserInput, EmailItemUncheckedUpdateWithoutUserInput>
    create: XOR<EmailItemCreateWithoutUserInput, EmailItemUncheckedCreateWithoutUserInput>
  }

  export type EmailItemUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailItemWhereUniqueInput
    data: XOR<EmailItemUpdateWithoutUserInput, EmailItemUncheckedUpdateWithoutUserInput>
  }

  export type EmailItemUpdateManyWithWhereWithoutUserInput = {
    where: EmailItemScalarWhereInput
    data: XOR<EmailItemUpdateManyMutationInput, EmailItemUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailItemScalarWhereInput = {
    AND?: EmailItemScalarWhereInput | EmailItemScalarWhereInput[]
    OR?: EmailItemScalarWhereInput[]
    NOT?: EmailItemScalarWhereInput | EmailItemScalarWhereInput[]
    id?: StringFilter<"EmailItem"> | string
    userId?: StringFilter<"EmailItem"> | string
    gmailId?: StringFilter<"EmailItem"> | string
    threadId?: StringNullableFilter<"EmailItem"> | string | null
    from?: StringFilter<"EmailItem"> | string
    subject?: StringFilter<"EmailItem"> | string
    snippet?: StringFilter<"EmailItem"> | string
    receivedAt?: DateTimeFilter<"EmailItem"> | Date | string
    isUnread?: BoolFilter<"EmailItem"> | boolean
    rawJson?: StringFilter<"EmailItem"> | string
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutUserInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutUserInput, CalendarEventUncheckedUpdateWithoutUserInput>
    create: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutUserInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutUserInput, CalendarEventUncheckedUpdateWithoutUserInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutUserInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutUserInput>
  }

  export type CalendarEventScalarWhereInput = {
    AND?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    OR?: CalendarEventScalarWhereInput[]
    NOT?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    id?: StringFilter<"CalendarEvent"> | string
    userId?: StringFilter<"CalendarEvent"> | string
    gcalId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    start?: DateTimeFilter<"CalendarEvent"> | Date | string
    end?: DateTimeFilter<"CalendarEvent"> | Date | string
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    rawJson?: StringFilter<"CalendarEvent"> | string
  }

  export type DocItemUpsertWithWhereUniqueWithoutUserInput = {
    where: DocItemWhereUniqueInput
    update: XOR<DocItemUpdateWithoutUserInput, DocItemUncheckedUpdateWithoutUserInput>
    create: XOR<DocItemCreateWithoutUserInput, DocItemUncheckedCreateWithoutUserInput>
  }

  export type DocItemUpdateWithWhereUniqueWithoutUserInput = {
    where: DocItemWhereUniqueInput
    data: XOR<DocItemUpdateWithoutUserInput, DocItemUncheckedUpdateWithoutUserInput>
  }

  export type DocItemUpdateManyWithWhereWithoutUserInput = {
    where: DocItemScalarWhereInput
    data: XOR<DocItemUpdateManyMutationInput, DocItemUncheckedUpdateManyWithoutUserInput>
  }

  export type DocItemScalarWhereInput = {
    AND?: DocItemScalarWhereInput | DocItemScalarWhereInput[]
    OR?: DocItemScalarWhereInput[]
    NOT?: DocItemScalarWhereInput | DocItemScalarWhereInput[]
    id?: StringFilter<"DocItem"> | string
    userId?: StringFilter<"DocItem"> | string
    fileId?: StringFilter<"DocItem"> | string
    title?: StringFilter<"DocItem"> | string
    sourceType?: StringFilter<"DocItem"> | string
    modifiedTime?: DateTimeFilter<"DocItem"> | Date | string
    extractedText?: StringNullableFilter<"DocItem"> | string | null
    textHash?: StringNullableFilter<"DocItem"> | string | null
    rawJson?: StringFilter<"DocItem"> | string
  }

  export type TaskUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutUserInput, TaskUncheckedUpdateWithoutUserInput>
    create: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutUserInput, TaskUncheckedUpdateWithoutUserInput>
  }

  export type TaskUpdateManyWithWhereWithoutUserInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    userId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    sourceType?: StringFilter<"Task"> | string
    sourceId?: StringNullableFilter<"Task"> | string | null
    dueAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    estMins?: IntNullableFilter<"Task"> | number | null
    priority?: StringFilter<"Task"> | string
    status?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type PlanUpsertWithWhereUniqueWithoutUserInput = {
    where: PlanWhereUniqueInput
    update: XOR<PlanUpdateWithoutUserInput, PlanUncheckedUpdateWithoutUserInput>
    create: XOR<PlanCreateWithoutUserInput, PlanUncheckedCreateWithoutUserInput>
  }

  export type PlanUpdateWithWhereUniqueWithoutUserInput = {
    where: PlanWhereUniqueInput
    data: XOR<PlanUpdateWithoutUserInput, PlanUncheckedUpdateWithoutUserInput>
  }

  export type PlanUpdateManyWithWhereWithoutUserInput = {
    where: PlanScalarWhereInput
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyWithoutUserInput>
  }

  export type PlanScalarWhereInput = {
    AND?: PlanScalarWhereInput | PlanScalarWhereInput[]
    OR?: PlanScalarWhereInput[]
    NOT?: PlanScalarWhereInput | PlanScalarWhereInput[]
    id?: StringFilter<"Plan"> | string
    userId?: StringFilter<"Plan"> | string
    weekStartDate?: DateTimeFilter<"Plan"> | Date | string
    planJson?: StringFilter<"Plan"> | string
    createdAt?: DateTimeFilter<"Plan"> | Date | string
  }

  export type TriageRunUpsertWithWhereUniqueWithoutUserInput = {
    where: TriageRunWhereUniqueInput
    update: XOR<TriageRunUpdateWithoutUserInput, TriageRunUncheckedUpdateWithoutUserInput>
    create: XOR<TriageRunCreateWithoutUserInput, TriageRunUncheckedCreateWithoutUserInput>
  }

  export type TriageRunUpdateWithWhereUniqueWithoutUserInput = {
    where: TriageRunWhereUniqueInput
    data: XOR<TriageRunUpdateWithoutUserInput, TriageRunUncheckedUpdateWithoutUserInput>
  }

  export type TriageRunUpdateManyWithWhereWithoutUserInput = {
    where: TriageRunScalarWhereInput
    data: XOR<TriageRunUpdateManyMutationInput, TriageRunUncheckedUpdateManyWithoutUserInput>
  }

  export type TriageRunScalarWhereInput = {
    AND?: TriageRunScalarWhereInput | TriageRunScalarWhereInput[]
    OR?: TriageRunScalarWhereInput[]
    NOT?: TriageRunScalarWhereInput | TriageRunScalarWhereInput[]
    id?: StringFilter<"TriageRun"> | string
    userId?: StringFilter<"TriageRun"> | string
    createdAt?: DateTimeFilter<"TriageRun"> | Date | string
    resultJson?: StringFilter<"TriageRun"> | string
  }

  export type LearningMaterialUpsertWithWhereUniqueWithoutUserInput = {
    where: LearningMaterialWhereUniqueInput
    update: XOR<LearningMaterialUpdateWithoutUserInput, LearningMaterialUncheckedUpdateWithoutUserInput>
    create: XOR<LearningMaterialCreateWithoutUserInput, LearningMaterialUncheckedCreateWithoutUserInput>
  }

  export type LearningMaterialUpdateWithWhereUniqueWithoutUserInput = {
    where: LearningMaterialWhereUniqueInput
    data: XOR<LearningMaterialUpdateWithoutUserInput, LearningMaterialUncheckedUpdateWithoutUserInput>
  }

  export type LearningMaterialUpdateManyWithWhereWithoutUserInput = {
    where: LearningMaterialScalarWhereInput
    data: XOR<LearningMaterialUpdateManyMutationInput, LearningMaterialUncheckedUpdateManyWithoutUserInput>
  }

  export type LearningMaterialScalarWhereInput = {
    AND?: LearningMaterialScalarWhereInput | LearningMaterialScalarWhereInput[]
    OR?: LearningMaterialScalarWhereInput[]
    NOT?: LearningMaterialScalarWhereInput | LearningMaterialScalarWhereInput[]
    id?: StringFilter<"LearningMaterial"> | string
    userId?: StringFilter<"LearningMaterial"> | string
    filename?: StringFilter<"LearningMaterial"> | string
    fileType?: StringFilter<"LearningMaterial"> | string
    extractedText?: StringNullableFilter<"LearningMaterial"> | string | null
    createdAt?: DateTimeFilter<"LearningMaterial"> | Date | string
  }

  export type UserCreateWithoutGoogleAccountInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    emailItems?: EmailItemCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    docItems?: DocItemCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGoogleAccountInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    emailItems?: EmailItemUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    docItems?: DocItemUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunUncheckedCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGoogleAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGoogleAccountInput, UserUncheckedCreateWithoutGoogleAccountInput>
  }

  export type UserUpsertWithoutGoogleAccountInput = {
    update: XOR<UserUpdateWithoutGoogleAccountInput, UserUncheckedUpdateWithoutGoogleAccountInput>
    create: XOR<UserCreateWithoutGoogleAccountInput, UserUncheckedCreateWithoutGoogleAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGoogleAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGoogleAccountInput, UserUncheckedUpdateWithoutGoogleAccountInput>
  }

  export type UserUpdateWithoutGoogleAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailItems?: EmailItemUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    docItems?: DocItemUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGoogleAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailItems?: EmailItemUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    docItems?: DocItemUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUncheckedUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEmailItemsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    docItems?: DocItemCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailItemsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountUncheckedCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    docItems?: DocItemUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunUncheckedCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailItemsInput, UserUncheckedCreateWithoutEmailItemsInput>
  }

  export type UserUpsertWithoutEmailItemsInput = {
    update: XOR<UserUpdateWithoutEmailItemsInput, UserUncheckedUpdateWithoutEmailItemsInput>
    create: XOR<UserCreateWithoutEmailItemsInput, UserUncheckedCreateWithoutEmailItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailItemsInput, UserUncheckedUpdateWithoutEmailItemsInput>
  }

  export type UserUpdateWithoutEmailItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    docItems?: DocItemUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUncheckedUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    docItems?: DocItemUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUncheckedUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCalendarEventsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountCreateNestedOneWithoutUserInput
    emailItems?: EmailItemCreateNestedManyWithoutUserInput
    docItems?: DocItemCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCalendarEventsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountUncheckedCreateNestedOneWithoutUserInput
    emailItems?: EmailItemUncheckedCreateNestedManyWithoutUserInput
    docItems?: DocItemUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunUncheckedCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCalendarEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
  }

  export type UserUpsertWithoutCalendarEventsInput = {
    update: XOR<UserUpdateWithoutCalendarEventsInput, UserUncheckedUpdateWithoutCalendarEventsInput>
    create: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCalendarEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCalendarEventsInput, UserUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type UserUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUpdateManyWithoutUserNestedInput
    docItems?: DocItemUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUncheckedUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUncheckedUpdateManyWithoutUserNestedInput
    docItems?: DocItemUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUncheckedUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDocItemsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountCreateNestedOneWithoutUserInput
    emailItems?: EmailItemCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocItemsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountUncheckedCreateNestedOneWithoutUserInput
    emailItems?: EmailItemUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunUncheckedCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocItemsInput, UserUncheckedCreateWithoutDocItemsInput>
  }

  export type UserUpsertWithoutDocItemsInput = {
    update: XOR<UserUpdateWithoutDocItemsInput, UserUncheckedUpdateWithoutDocItemsInput>
    create: XOR<UserCreateWithoutDocItemsInput, UserUncheckedCreateWithoutDocItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocItemsInput, UserUncheckedUpdateWithoutDocItemsInput>
  }

  export type UserUpdateWithoutDocItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUncheckedUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUncheckedUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTasksInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountCreateNestedOneWithoutUserInput
    emailItems?: EmailItemCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    docItems?: DocItemCreateNestedManyWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountUncheckedCreateNestedOneWithoutUserInput
    emailItems?: EmailItemUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    docItems?: DocItemUncheckedCreateNestedManyWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunUncheckedCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type UserUpsertWithoutTasksInput = {
    update: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    docItems?: DocItemUpdateManyWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUncheckedUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    docItems?: DocItemUncheckedUpdateManyWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUncheckedUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPlansInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountCreateNestedOneWithoutUserInput
    emailItems?: EmailItemCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    docItems?: DocItemCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlansInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountUncheckedCreateNestedOneWithoutUserInput
    emailItems?: EmailItemUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    docItems?: DocItemUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunUncheckedCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlansInput, UserUncheckedCreateWithoutPlansInput>
  }

  export type UserUpsertWithoutPlansInput = {
    update: XOR<UserUpdateWithoutPlansInput, UserUncheckedUpdateWithoutPlansInput>
    create: XOR<UserCreateWithoutPlansInput, UserUncheckedCreateWithoutPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlansInput, UserUncheckedUpdateWithoutPlansInput>
  }

  export type UserUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    docItems?: DocItemUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUncheckedUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    docItems?: DocItemUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUncheckedUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTriageRunsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountCreateNestedOneWithoutUserInput
    emailItems?: EmailItemCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    docItems?: DocItemCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTriageRunsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountUncheckedCreateNestedOneWithoutUserInput
    emailItems?: EmailItemUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    docItems?: DocItemUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    learningMaterials?: LearningMaterialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTriageRunsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTriageRunsInput, UserUncheckedCreateWithoutTriageRunsInput>
  }

  export type UserUpsertWithoutTriageRunsInput = {
    update: XOR<UserUpdateWithoutTriageRunsInput, UserUncheckedUpdateWithoutTriageRunsInput>
    create: XOR<UserCreateWithoutTriageRunsInput, UserUncheckedCreateWithoutTriageRunsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTriageRunsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTriageRunsInput, UserUncheckedUpdateWithoutTriageRunsInput>
  }

  export type UserUpdateWithoutTriageRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    docItems?: DocItemUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTriageRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUncheckedUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    docItems?: DocItemUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    learningMaterials?: LearningMaterialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLearningMaterialsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountCreateNestedOneWithoutUserInput
    emailItems?: EmailItemCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    docItems?: DocItemCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    plans?: PlanCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLearningMaterialsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    googleAccount?: GoogleAccountUncheckedCreateNestedOneWithoutUserInput
    emailItems?: EmailItemUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    docItems?: DocItemUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    plans?: PlanUncheckedCreateNestedManyWithoutUserInput
    triageRuns?: TriageRunUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLearningMaterialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLearningMaterialsInput, UserUncheckedCreateWithoutLearningMaterialsInput>
  }

  export type LearningArtifactCreateWithoutLearningMaterialInput = {
    id?: string
    type: string
    artifactJson: string
    createdAt?: Date | string
  }

  export type LearningArtifactUncheckedCreateWithoutLearningMaterialInput = {
    id?: string
    type: string
    artifactJson: string
    createdAt?: Date | string
  }

  export type LearningArtifactCreateOrConnectWithoutLearningMaterialInput = {
    where: LearningArtifactWhereUniqueInput
    create: XOR<LearningArtifactCreateWithoutLearningMaterialInput, LearningArtifactUncheckedCreateWithoutLearningMaterialInput>
  }

  export type LearningArtifactCreateManyLearningMaterialInputEnvelope = {
    data: LearningArtifactCreateManyLearningMaterialInput | LearningArtifactCreateManyLearningMaterialInput[]
  }

  export type UserUpsertWithoutLearningMaterialsInput = {
    update: XOR<UserUpdateWithoutLearningMaterialsInput, UserUncheckedUpdateWithoutLearningMaterialsInput>
    create: XOR<UserCreateWithoutLearningMaterialsInput, UserUncheckedCreateWithoutLearningMaterialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLearningMaterialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLearningMaterialsInput, UserUncheckedUpdateWithoutLearningMaterialsInput>
  }

  export type UserUpdateWithoutLearningMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    docItems?: DocItemUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    plans?: PlanUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLearningMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleAccount?: GoogleAccountUncheckedUpdateOneWithoutUserNestedInput
    emailItems?: EmailItemUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    docItems?: DocItemUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    plans?: PlanUncheckedUpdateManyWithoutUserNestedInput
    triageRuns?: TriageRunUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LearningArtifactUpsertWithWhereUniqueWithoutLearningMaterialInput = {
    where: LearningArtifactWhereUniqueInput
    update: XOR<LearningArtifactUpdateWithoutLearningMaterialInput, LearningArtifactUncheckedUpdateWithoutLearningMaterialInput>
    create: XOR<LearningArtifactCreateWithoutLearningMaterialInput, LearningArtifactUncheckedCreateWithoutLearningMaterialInput>
  }

  export type LearningArtifactUpdateWithWhereUniqueWithoutLearningMaterialInput = {
    where: LearningArtifactWhereUniqueInput
    data: XOR<LearningArtifactUpdateWithoutLearningMaterialInput, LearningArtifactUncheckedUpdateWithoutLearningMaterialInput>
  }

  export type LearningArtifactUpdateManyWithWhereWithoutLearningMaterialInput = {
    where: LearningArtifactScalarWhereInput
    data: XOR<LearningArtifactUpdateManyMutationInput, LearningArtifactUncheckedUpdateManyWithoutLearningMaterialInput>
  }

  export type LearningArtifactScalarWhereInput = {
    AND?: LearningArtifactScalarWhereInput | LearningArtifactScalarWhereInput[]
    OR?: LearningArtifactScalarWhereInput[]
    NOT?: LearningArtifactScalarWhereInput | LearningArtifactScalarWhereInput[]
    id?: StringFilter<"LearningArtifact"> | string
    learningMaterialId?: StringFilter<"LearningArtifact"> | string
    type?: StringFilter<"LearningArtifact"> | string
    artifactJson?: StringFilter<"LearningArtifact"> | string
    createdAt?: DateTimeFilter<"LearningArtifact"> | Date | string
  }

  export type LearningMaterialCreateWithoutArtifactsInput = {
    id?: string
    filename: string
    fileType: string
    extractedText?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLearningMaterialsInput
  }

  export type LearningMaterialUncheckedCreateWithoutArtifactsInput = {
    id?: string
    userId: string
    filename: string
    fileType: string
    extractedText?: string | null
    createdAt?: Date | string
  }

  export type LearningMaterialCreateOrConnectWithoutArtifactsInput = {
    where: LearningMaterialWhereUniqueInput
    create: XOR<LearningMaterialCreateWithoutArtifactsInput, LearningMaterialUncheckedCreateWithoutArtifactsInput>
  }

  export type LearningMaterialUpsertWithoutArtifactsInput = {
    update: XOR<LearningMaterialUpdateWithoutArtifactsInput, LearningMaterialUncheckedUpdateWithoutArtifactsInput>
    create: XOR<LearningMaterialCreateWithoutArtifactsInput, LearningMaterialUncheckedCreateWithoutArtifactsInput>
    where?: LearningMaterialWhereInput
  }

  export type LearningMaterialUpdateToOneWithWhereWithoutArtifactsInput = {
    where?: LearningMaterialWhereInput
    data: XOR<LearningMaterialUpdateWithoutArtifactsInput, LearningMaterialUncheckedUpdateWithoutArtifactsInput>
  }

  export type LearningMaterialUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLearningMaterialsNestedInput
  }

  export type LearningMaterialUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailItemCreateManyUserInput = {
    id?: string
    gmailId: string
    threadId?: string | null
    from: string
    subject: string
    snippet: string
    receivedAt: Date | string
    isUnread: boolean
    rawJson: string
  }

  export type CalendarEventCreateManyUserInput = {
    id?: string
    gcalId: string
    title: string
    start: Date | string
    end: Date | string
    location?: string | null
    rawJson: string
  }

  export type DocItemCreateManyUserInput = {
    id?: string
    fileId: string
    title: string
    sourceType: string
    modifiedTime: Date | string
    extractedText?: string | null
    textHash?: string | null
    rawJson: string
  }

  export type TaskCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    sourceType: string
    sourceId?: string | null
    dueAt?: Date | string | null
    estMins?: number | null
    priority: string
    status: string
    createdAt?: Date | string
  }

  export type PlanCreateManyUserInput = {
    id?: string
    weekStartDate: Date | string
    planJson: string
    createdAt?: Date | string
  }

  export type TriageRunCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    resultJson: string
  }

  export type LearningMaterialCreateManyUserInput = {
    id?: string
    filename: string
    fileType: string
    extractedText?: string | null
    createdAt?: Date | string
  }

  export type EmailItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailId?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    snippet?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUnread?: BoolFieldUpdateOperationsInput | boolean
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type EmailItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailId?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    snippet?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUnread?: BoolFieldUpdateOperationsInput | boolean
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type EmailItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailId?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    snippet?: StringFieldUpdateOperationsInput | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUnread?: BoolFieldUpdateOperationsInput | boolean
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type DocItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    modifiedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    textHash?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type DocItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    modifiedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    textHash?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type DocItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    modifiedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    textHash?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estMins?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estMins?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estMins?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriageRunUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultJson?: StringFieldUpdateOperationsInput | string
  }

  export type TriageRunUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultJson?: StringFieldUpdateOperationsInput | string
  }

  export type TriageRunUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultJson?: StringFieldUpdateOperationsInput | string
  }

  export type LearningMaterialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: LearningArtifactUpdateManyWithoutLearningMaterialNestedInput
  }

  export type LearningMaterialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: LearningArtifactUncheckedUpdateManyWithoutLearningMaterialNestedInput
  }

  export type LearningMaterialUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningArtifactCreateManyLearningMaterialInput = {
    id?: string
    type: string
    artifactJson: string
    createdAt?: Date | string
  }

  export type LearningArtifactUpdateWithoutLearningMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    artifactJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningArtifactUncheckedUpdateWithoutLearningMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    artifactJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningArtifactUncheckedUpdateManyWithoutLearningMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    artifactJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearningMaterialCountOutputTypeDefaultArgs instead
     */
    export type LearningMaterialCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearningMaterialCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GoogleAccountDefaultArgs instead
     */
    export type GoogleAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GoogleAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailItemDefaultArgs instead
     */
    export type EmailItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarEventDefaultArgs instead
     */
    export type CalendarEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocItemDefaultArgs instead
     */
    export type DocItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanDefaultArgs instead
     */
    export type PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TriageRunDefaultArgs instead
     */
    export type TriageRunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TriageRunDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearningMaterialDefaultArgs instead
     */
    export type LearningMaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearningMaterialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearningArtifactDefaultArgs instead
     */
    export type LearningArtifactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearningArtifactDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}